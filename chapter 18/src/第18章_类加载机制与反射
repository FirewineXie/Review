第十八章_类加载和反射机制
    18.1 类的加载、连接和初始化
        java类加载器除了根类加载器之外，其他都是java编写的，所以程序员可以开发自己的类加载器，通过使用自定义类加载器，可以完成一些特定的功能

        本章介绍Proxy 和InvocationHandle 来创建jdk动态代理，
        18.1.1 JVM 和类
            同一个JVM 的所有线程、所有变量都处于同一个进程里，他们都使用JVM进程的内存区
            {
                程序正常结束
                System.exit() 和 Runtime.getRuntime().exit() 代码结束程序
                程序执行过程，遇到未捕获的异常或错误而结束
                程序所在平台强制结束了JVM进程
            }

            这里有个重点是，如果你创建一个类的两个实例，然后调用，但是他们虽然存在一个内存区，但是不是一个JVM进程，所以，他们的变量的值都是不共同的。

        18.1.2 类的加载
            当程序使用某个类的时候，如果该类还未加载到内存中，则系统会通过加载，连接，初始化三个步骤

        18.1.4 类的初始化
            java类中对类变量执行初始值有两种方式：{
                1.声明类变量时执行初始值
                2.使用静态初始化块为类变量指定初始值
            }

        18.1.5 类初始化的时机
            在这个值得了解的时候，是，如果你的变量使用final 来修饰的话，那么修饰的变量会在编译的时候就确定下来，如果调用不会去初始化所在的类

            当使用ClassLoader 类的LoadClass 方法来加载某个类时，该方法只是加载该类，并没有初始化，，当使用Class的forname 静态方法才会导致强制初始化该类。

    18.2 类加载器
        类加载器是将class 文件加载到内存中，

        18.2.1 类加载机制
            在java中，一个类用其全限定类名（包括包名和类名） 作为标识，
            但在JVM中，使用的是全限定类名和其类加载器作为唯一标识。

            当JVM启动的时候，会形成三个类加载器组成的初始化类加载器层次结构{
                Bootstrap ClassLoader 根类加载器
                Extension ClassLoader 扩展类加载器
                System ClassLoader 系统类加载器
            }

            而用户创建的加载器，是在继承ClassLoader 来实现的，，
        18.2.2 创建并使用自定义的类加载器
            JVM 中除跟类加载器之外的所有类加载器都是ClassLoader 子类的实例，开发者可以通过扩展ClassLoader的子类，并重写该ClassLoader所包含的方法来实现自定义的类加载器

            ClassLoader类有如下两个关键方法{
                loadClass（String name,boolen resolve） 该方法为ClassLoader 的入口点，根据名称来加载类，
                findClass（String name） 根据指定名称来查找类
            }

            如果想要自定义ClassLoader 推荐重写FindClass 类，可以避免覆盖默认类加载器的父类委托，缓冲机制两种策略，

        18.2.3 URLClassLoader 类
            该类也是系统类加载器和扩展类加载器的父类，这个类可以从本地也可以从远程主机获取二进制文件来加载类。

            URLClassLoader 使用默认的父类加载器创建一个ClassLoader对象，该对象的urls 所指定的系列路径来查询并加载类

    18.3 通过反射查看类信息
        Java的对象在运行的都会出现两种类型：编译式类型和运行时类型，，
        如果程序在运行的时候就会接受到外部插入的一个对象，但是编译类型是Object 但程序需要调用该对象运行时类型的方法

        {
            第一种是，在编译时和运行时，已经知道了类型的具体信息，，，可以用instanceof判断，然后进行强制转换
            第二种是，编译的时候，无法去预支，，只能考运行时的信息，就要通过反射
        }
        18.3.1 获得Class对象
            获得class对象有三种方法{
                1.使用Class类的forname 静态方法，参数必须是某个类的全限定名
                2.调用某个类的Class属性来获取该类对应的CLass对象，例如  domo.class
                3. 使用某个对象的getClass 方法，
            }

        18.3.2 从Class中获取信息
            可以获取构造器，方法，成员变量，注解，内部类，获取class对象的修饰符，所在包，类名等基本信息
            还可获取判断该类是否为接口等类型，
        18.3.3 java 8 新增的方法参数反射
            在java.lang .reflect 包下新增了Executable 抽象基类，派生出两个子类：COnstructor，Method

            这个类提供了大量方法来获取修饰该方法或构造器的注解信息，：还提供了isVarArgs 方法用于判断该方法或构造器是否包含数量可变的形参，和getModifiers得到方法或形参
    18.4 使用反射生成并操作对象

        方法  ---- 》 Method
        构造器 -----》 Constructor
        成员变量 ----》 Field

        18.4.1 创建对象
            如果想要创建对象，首先使用Class对象获取指定的Constructor 对象，再调用Constructor对象的NewInstance 方法来创建该Class 对象对象对应类的实例

        18.4.3 访问成员变量值
            通过Class对象的GetFields 或getField 方法可以获取该类所包括的全部成员变量或指定成员变量。



        18.4.4 操作数组
            reflect 类里提供了Array类，，可以代表所有数组
            看代码


    18.5 使用反射生成JDK动态代理
        18.5.1 使用Proxy和 InvocationHandle 创建动态代理
            Proxy 提供了用于创建动态代理和代理对象的静态方法，它也是所有动态代理类的父类，


            系统生成的每个 代理对象都有一个与之关联的InvocationHandle 对象

    18.6 反射和泛型


    aop（面向切面） 和反射，，还要再进行研究




