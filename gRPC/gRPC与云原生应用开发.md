# gRPC与云原生应用开发



## 一、gRPC 入梦

> 微服务架构定义： 
>
> ​		 是将软件应用程序构建为一组独立、自治（独立开发、部署和扩展）、松耦合、面向业务能力[^1]的服务。
>
> 微服务架构和云原生架构，就是为了多种业务能力所构建的传统软件系统被进一步拆分为一组细粒度、自治和面向业务能力的实体，也就是微服务。

[^1]: 更强调的是软件系统所具有的的能力，而不仅仅是完成指定的任务



进程间通信方式——————`事务代理`

1. 通常使用 消息传递的方式
2. 同步的请求-响应 风格
3. 异步的事件驱动风格（进程间会通过异步消息传递进行通信）

> gRPC：
>
> ​		主要采用的是 请求-响应风格进行通信，但在建立初始连接后，它完成可以以异步模式或流模式进行操作。
>
> 但是 不建议消息大小在1M 以上，如果达到，可以考虑更加合适的方法传递。





### 1.1 gRPC 的定义

> 服务接口 包含  ： 消费者消费服务的方式、消费者能够远程调用的方法以及调用这些方法所使用的参数和消息格式等。 ———————— 被称作为 `IDL`[^2]
>
> gRPC 采用 HTTP/2 进行消息发送

[^2]: 接口定义语言

> 代理的不同叫法：
>
> 1. 骨架： 服务定义生成的服务器端代码
> 2. 存根： 服务定义生成的客户端代码



#### 1.1.1 服务定义

服务接口定义在proto文件中指定。

```protobuf
//product_info.proto
syntax = "proto3";  // 1. proto3版本必须显示指定，不然默认为proto2

//package ecommerce;  // 2. 用来防止协议消息类型之间发生命名冲突的包名，该报名也会用来生成代码
option go_package = ".;ecommerce"; //补充，go protoc 要求必须指定go_package 而不是package

// 3. 定义gRPC 服务的接口
service ProductInfo {
  // 4.添加商品的远程方法，并返回商品id
  rpc AddProduct(Product)returns (ProductId);
  //  5. 获取产品详情
  rpc GetProduct(ProductId)returns (Product);
}

// 6. 定义消息格式或类型
message Product{
  string id = 1; // 7. 数字为地址编号，详细内容[https://blog.csdn.net/xyjworkgame/article/details/119057144?spm=1001.2014.3001.5501]
  string name = 2;
  string description = 3;
}

message ProductId{
  string value = 1;
}



// protoc -I ecommerce --go_out=ecommerce  ecommerce\product_info.proto
```



#### 1.1.2 服务器端

#### 1.1.3 客户端

> 后序代码中展示



### 1.2 进程间通信技术的演化



#### 1.2.1 传统的RPC

- 通用对象请求代理体系结构（CORBA）
- java 远程调用方法（RMI）

#### 1.2.2 SOAP

> 简单对象访问协议（SOAP）：
>
> ​       是**面向服务的架构（SOA）**中的标准通信技术，用于通常在web服务之间交换xml的结构化数据，并且能够基于任意的底层通信协议进行通信，常见的就是HTTP

#### 1.2.3 REST

> **描述性状态转移（REST）**
>
> **面向资源架构（ROA）**

REST 服务的3 个局限性：

1. 基于文本的低效消息协议

   使用人类可读的文本，但是机器并不需要这个文本化格式，使用低效

2. 应用程序之间缺乏强类型接口

3. REST架构风格难以强制实施



#### 1.2.4 gRPC 起源

Baidu 至上

#### 1.2.5 选择gRPC 原因

##### gRPC 优势

1. 提供高效的进程间通信

2. 具有简单且定义良好的服务接口和模式

3. 属于强类型

4. 支持多语言

5. 支持双工流

6. 具备内置的商业化特性

   一般指向 ： 认证、加密、弹性（截止时间和超时）、元数据交换、压缩、负载均衡、服务发现等

7. 与云原生生态系统进行集成

8. 已成熟被广泛使用

##### gRPC劣势

1. 不太适合面向外部的服务
2. 巨大的服务定义变更是复杂的开发流程
3. gRPC 生态系统相对较小



#### 1.2.6 与其他协议对比： Thrift和 GraphQL



##### 与Thrift对比

1. 传输方面

2. 流方面

   gRPC 原生支持 双向流，本身就是服务定义的一部分

3. 采用情况和社区资源方面

4. 性能方面

   虽然Thrift 有点强，但是性能不是唯一考虑标准

##### GraphQL

GraphQL 用于面向外部的服务或API

gRPC 更适用于内部的服务





## 二、开始使用gRPC



###  2.1 创建服务定义

**消息** 是客户端和服务器端交换的数据结构

`第一章所提及：`不能为字段设置相同的数字

**服务** 是暴露给客户端的远程方法的集合——（protocol-buffers 规定，只能有一个请求类型和响应类型）

具体

**包名** 可以指定包名，但是在go 中，包名的名称为`go_package  `

**导入** 可以导入其他proto 文件的定义好的消息类型

```protobuf
syntax = "proto3";
import "google/protobuf/wrappers.protp";
```





### 2.2 实现

#### 2.2.1 开发服务

目录架构（不是生产架构）

![image-20210724170935905](gRPC与云原生应用开发/image-20210724170935905.png)

