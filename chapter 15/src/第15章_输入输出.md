[TOC]()

# 第十五章 java的输入输出

## 概述

1. java 的IO流 有两种 ： 字节流和字符流
2. 在java的IO流使用了一种装饰器模式， 它可以将IO 分成底层节点和上层处理流，这样更有利用使用输入输出

## 15.1 File类

1. File类可以 操作目录，文件，

**但是不可以操作文件本身**

### 15.1 访问文件和目录
1. 目录的路径 既可以是 绝对路径 也可以是 相对路径
相对路径 就是在 java的虚拟机的所在的路径的基础上来看待的

2. 并且可以获取到文件的常规信息，内容的长度和文件的最后修改时间
3. 在这里还可以创建临时文件，有着很大的重要性，

### 15.1.2 文件过滤器

1. File 类的list方法有一个参数 是FIlenameFilter 参数，通过该参数可以只列出符合条件的文件

**这里有一个混淆点 ； 就是FilenameFileFilter 接口 和javax。swing。FIlechooser 包下的FIleFilter抽象类的功能是非常相似的，记得区别**

2. 可以实现accept 方法 ，该方法将依次对指定的File的所有子目录或者文件进行迭代
 
## 15.2 理解java的IO流

* 首先明白 java中的输入输出流是对于内存来说的，
    * 举个例子
        1. 输入流 ： 就是从数据源读数据到电脑中
        2. 输出流 ： 就是从内存读数据到硬盘中
* java的输出流 主要由 InputStream 和Reader作为基类，而输出流 则主要由OutputStream 和 Writer 作为基类。
* 字节流操作的数据单元 是8位的字节，字符流操作的数据单位是16 位的字符

* 按照流的分类：
    节点流， 处理流
    
    * 处理流 ： 就是对一个已存在的流进行连接或封装，通过封装后的流来实现读写功能。
    * java使用处理流来包装节点流 是一种典型的装饰器设计模式

### 流的概念模型

对于InputStream/Reader而言，他们把输入设备抽象成一个水管，这个水管的每个水滴一次排列
* 这个里面还有个隐式的记录指针来表示当前水滴即将放入的位置。


可以通过处理流，java程序无需理会输出和输入的节点是什么，网络还是其他的设备，程序只要将这些节点流包装成处理流，就可以使用相同的
代理来处理不同的设备的数据

### 字节流和字符流 

他们的方法都是类似的，就是处理的对象不一样而已，一个是字节一个字符，

通常都是用三个方法，读取单个，读取为数组，读取指定的长度的数组

* 当数组的返回值的是-1 就是表明输入流的结束点


## 15.4 输入输出流体系

当然使用 上面的节点流，非常的麻烦，的
可以如果使用处理流，就会显得非常的简单

### 15.4.1 处理流的用法

在类中，，可以看到例子

### 15.4.2 输入输出流体系

java的输入和输出流 有很多的类，但是是非常的通用的

还有一种是管道流 那个是可以用在进程之间通信功能的
而 缓冲流的 增加了缓冲的功能， 但是记得要使用flush 进行写入


## 15.5 重定向标准输入/输出

1. java 的输出输入都是默认是键盘输入和屏幕输出

2. System类里提供三个重定向  就是setErr 和SetIn 和setOut


## RandomAccesssFIle 

这个是 java 输入/输出 流体系中功能最丰富 的文件内容访问类，他提供了众多的方法来访问文件内容，
并且支持随机访问 ，程序可以 直接跳转到文件的任意地方发来读写数据

但是重要的是  这个类只能 读写文件， 不能读写其他IO

两个方法来操作文件记录指针
```text
long getFilePointer

void seek(long pos)
```

有两个构造器，功能一样，这是形式不同，
一个使用 String 参数来指定文件名，
一个使用 File参数 来指定 文件本身

I 以只读的方式打开文件
rw 以读写的方式打开文件，如果没有会 尝试创建
rws 在上面的基础上，还要求对文件的内容或元数据的每个更新 都同步写入到底层存储设备
rwd 相当于rw 模式 还要求对文件内容的每个更新 都同步写入到底层存储设备

## JAVA9  改进的对象序列化
   
   对象序列化的目标 是将对象 保存到磁盘中 ，或容许在网络中直接传输对象，
   就是将 java对象 转化成二进制中， 使得可以独立的存在
   
 1. 实现两个接口 ：Serializable 和Externalizable 
 无需实现什么，只需要实现接口，，就好
 **通常建议，，程序创建的每个JavaBean类都实现Serializable **


对于反序列化，， 返回的是仅仅是java对象的数据，而不是java类，因此采用反序列化恢复java对象时，必须要提供java对象的所属类的class文件

当一个类进行序列化的时候，这些父类要么有无参数的构造器，，要么也是可以序列化的，不然抛出 InvalidClassException 异常


### 15,8,4 增加的过滤功能

java9 增加了 setObjectInputFilter ，getObjectInputFilter 两个方法，其中第一个方法
用于为对象输入流设置过滤器，
检查 序列化 数据有三个状态值

1. status.REJECTED 拒绝恢复 
2. Status.ALLOWED 容许恢复
3. Sstatus.UNDECIDED 未决定状态


### 15.8.5 自定义序列化

如果一个类里包含的某些实例变量时敏感信息，
如果不希望 系统将 该实例变量值 进行序列化 使用transient 关键字在属性的位置 修饰

但是使用关键字来进行修饰，那么反序列化的时候，就会出现， 无法取得该实例的变量
但是下面会提供 一种 自定义机制，
通过重写 writeObject 方法负责 写入特定类的实例状态，以便相应的readObject 方法可以恢复它

一种是操作简单的 Serializable 接口
一种是操作复杂但是 性能好的接口 到那时要实现两个方法
### 15.8.7 版本

java序列化机制容许为序列化类提供一个UID的值，该类的变量的值是用于标识 该java 类的序列化的版本
即是 这个类已经改变或者升级，但是只要版本号没有发生变化，，java还是认为这是一个序列化版本



### 15.9 NIO 可以说现在都是用的是NIO吗

这个是 提供了改进的输入输出的功能



### 文件锁

现在很多的操作系统也是都在使用文件锁，就是 使用这个，可以有效的阻止多个进程并发修改同一个文件，

在java中 提供了FileLock 来支持文件锁定功能， lock和trylock 两个方法，

lock 是尝试对某个文件进行加锁，并且若果无法得到会造成阻塞
trylock  是尝试锁定文件， 他将直接返回而不是阻塞，，

参数有一个是shared boolean 类型 了，，可以指定 共享锁 还是排它锁


### NIO2

一共有两个工具类 Files 和 Paths
 
Files 提供 操作文件的工具类
Paths  提供了路径的问题操作工具类

使用FileVisitor 遍历文件和目录 ，可以通过继承 SimpleFileVisitor 来实现自己的“文件访问器” 

使用WatchService 监控文件变化 来监控文件变化 {

   
 1. 如果需要一直监控，应当选择使用take 方法，
 2. 只需要指定时间监控使用 poll方法
 3. 
}


