### 第十六章 多线程

1. 在计算机操作系统中 ： 程序就是进程
2. 进程是 处于 运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位
3. 进程有三个特征 ： 独立性，动态性，并发性

但是实际上 ： CPU 只能在一个时间内，做一件事，而线程是进程的执行单元

* 总结来说： 一个程序 运行后至少有一个进程 ，一个进程 里可以包含多个线程吗，但至少要包含一个线程


1. 使用多线程的好处：
    * 进程之间不能共存内存，而线程可以
    * 系统创建进程时需要为该进程重新分配系统资源，当创建线程就比较容易
    * java语言内置了多线程的功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化开发
    
## 线程的创建和启动
   
1. 继承Thread 创建线程类
    1. 定义Thread 类的子类，并重写run方法，run就代表线程需要完成的任务
    2. 创建实例，并且创建对象
    3. 调用线程对象的start方法来启动该线程
2. 实现Runnable 接口去创建线程类
    1. 定义接口的实现类，，重写run方法
    2. 创建类的实例 但是**此实体 是通过 Thread 的target 来创建的Thread 对象 ，这才是真正的线程对象**
3. 实现Callable 和Futura创建线程
    * 这个 Callable跟其他的不同，他可以有返回值，并且可以声明异常，
    * Future 接口定义了如下几个公共方法来控制他关联的Callable任务
        * boolean cancel ； 试图取消该Future 里关联的Callable 任务
        * V get ： 返回Callab 任务里的Call方法的返回值
        * 等等
        
    1. 创建Callable 接口的实现类，并且实现方法
    2. 使用FutureTask 来来包装Callab对象 ，并且封装了 Callable 对象的Call方法的返回值
    3. 使用Future 对象作为Thread 对象的target 创建并启动新线程
    4. 使用Future 对象的get方法来获得子线程执行结束后的返回值
    
## 线程的生命周期
* 总共有 新建，就绪，运行，阻塞，死亡 五个周期
* 线程中一个重要的事情就是 ： 尽量不要使用suspend 方法 将该线程挂起，容易造成死锁



#### 控制线程
1. join线程
    * 让一个线程等待 另一个线程 完成的方法 
    * 一个能够将大问题逐渐变成一个个小问题去解决
2. 后台线程
    * 能够在后台用行的，任务是为其他的线程提供服务， jVM 的垃圾回收线程就是典型的后台线程
    * Thread的setDaemon方法 可以执行线程设置成后台线程
3. 线程睡眠
    * 可以当前正在运行的程序能够 暂停一段时间，并且进入阻塞状态
    * sleep方法
    
#### 改变线程你的优先级

1. Thread 类提供了setPriority有参 和setPriority无参 来设置和返回指定线程的优先级，
2. 范围是1-10 之间， 有三个静态常量分别是1 ，5,10


#### 线程同步

如果多个线程会使用同一个对象的，有可能造成逻辑错误，
1. 就得使用同步监视器 就是用同步代码块来实现 这个操作

2. 代码
```text
synchronized(obj){
    //此处的代码就是同步代码块
}
```
3. 除了像上面的代码块，还可以用synchronized 来修饰方法，，就是同步方法，，更加的方便

4. 还用一种方法就是同步锁
    1. 锁还提供了对共享资源的独占访问，每次只能有一个线程对lock对象加锁，线程如果开始访问共享资源，必须获得lock对象
    
    
### 死锁就不写了，，
自己注意就好了



### 线程通信

1. 传统的线程通信

是借助于Object的三个方法 wait notify notifyAll
* wait  导致当前的线程等待
* notify 唤醒在此同步监视器上等待的单个线程 ，如果所有线程都在等待，则是随机挑选
* notifyAll  是同时唤醒所有的线程

2. 使用Condition 控制线程通信
* 如果系统中不存在隐式的同步监视器 ，也就不能使用wait notify 等等了

java提供了 Condition 来保持协调，可以让那些占有锁，但是 无法执行的线程释放lock对象
* 有三个方法 await signal signalALl  与上面类似

3. 使用阻塞队列BlockQueue 控制线程通信
这个就是像操作系统将的一样，，那个是自己定义的，这个是已经设置好的
特征 ： 就是如果队列为空的，那个线程 就回阻塞


### 线程组

ThreadGroup 可以对一组数组进行同样的操作



### 线程池

可以利用线程池 去执行 线程任务
1. 调用Executors 类的静态工厂方法创建一个ExecutorService 对象 就代表一个线程池
2. 创建 Runnable 实现类 或Callable 实现类的实例，作为线程执行任务
3. 调用ExecutorService 对象的submit 方法来提交 Runnable 实例 或Callable 实例
4. 当不想提交任何任务时，调用ExecutorService对象的shutdown关闭线程池


### ForkJoinPool 

这个是利用多核CPU进行 执行线程任务，看例子



### 守护线程
1. Thread.setDemon  改变用户线程为守护线程
- 守护线程 是以 用户线程为中心，只有当用户线程 执行完成后，守护线程才关闭


### 代理角色和真是名称
1. 真实名称，通过上文中的currentThread : 
2. setName，getName 为代理名称



## 时间调度
quartz 可以让代码更加简洁，连贯


 happenbefore 即 ： 编译器或运行环境为了**优化程序性能**而采取的对指令进行重新排序的执行的一种手段


## Volatile : 保证线程间变量的可见性
Volatie 是不错的机制，但是不能保证原子性
但是 可以提高 执行效率

## ThreadLocal 就是保证在多线程的情况，保证成员变量的安全
get/set/initvalue 三个方法



## 可重复锁
大多数内置锁都是可重入的，就是说
(看截图)


## CAS