第六章_面向对象下
    6.1 java8增强的包装类
        8种基本类型的类型，都有相对应的包装类，
        然后java1.5提供了自动装箱，和自动拆箱的两个功能
        自动装箱：就是把一个基本类型变量直接赋给对应的包装类变量。或者赋给object变量

        包装类还可实现基本类型变量和字符串之间的转换，则将字符串转换成基本类型有两种方式：
            利用包装类提供的parseXXX（）方法，，除了CHaracter
            利用包装类提供的valueof()静态方法
            还可以 在变量值后面加上"" 直接变成从基本类型变成字符串。

            但是包装类的实例依旧可以与数据类型的值进行比较，这种比较是直接取出包装类实例所包装的数值来进行比较的
            java7提供了compare方法来比较两个基本类型值的大小，包括bolean的值
            java8为整形包装类增加了无符号运算方法，Integer和Long 增加的以下的方法。可以看api文档。
            还为short和Byte增加toUnsignedInt和toUnsignedLong方法，用于将byte和short类型，转换成int或long无符号值
    6.2 处理对象
        6.2.1 打印对象和toString方法
            toString方法既可以转换字符串，也可以当做对象的描述信息（自我描述）用以告诉外界该对象具有的状态信息
            Object提供的toString方法返回的是 类名+@+hashCode
        6.2.2 ==和equals 方法
            测试两个变量是否相等，有两种方式：一种是利用==运算符，另一种是利用equals方法
            ==可以用来测试基本数据类型的值是否相等，也可以判断两个引用变量指的是否是同一个对象，（但是不可以比较类型上没有父子关系的两个关系）
            {
                常量池：专门用于管理在编译时被确定并被保存在已编译的class文件，中的一些数据。它包括了关于类，方法，接口中的常量，
            }
            其实equals 的实际效果与==没有什么区别，所以在是在情况，要重写equals方法来满足业务要求
    6.3 类成员
        6.3.1 理解类成员
            通过前面已经了解很多了，所以这块不重复说，就说static，用着修饰符表示，它所修饰的都会变成类属于的。
            他只能通过类来调用或者访问，或者实例对象来访问（是因为想上转型了）
            而起类成员不可以调用实例成员（因为类成员先编译，而这时实例或许还没有编译，造成错误）
        6.3.2 单例（Singleton)类
            如果想要一个类只用一个对象，就可以使用这个，
            通过代码可以方便了解。
            使用getInstance方法提供的自定义控制。。
    6.4 final 修饰符
        final可以修饰类，变量和方法，。用于表数所修饰的东西是不可改变的。
        6.4.1 final 成员变量
            成员变量是随类初始化或对象初始化而初始化的。
            最重要一点就是：final修饰的成员变量必须由程序员显式指定初始值。
            注意：{  如果你不是直接给予final修饰的变量赋值，而是在构造器和初始化块中给与值， 此时就会看到值成为了默认的0等

                  }
            虽然final成员变量在显式初始化之前不能直接访问，但是可以用方法来访问，这是java的缺陷，所以尽量避免这样的错误出现。
        6.4.3 final修饰基本类型变量和引用类型变量的区别
            final修饰的基本类型变量是对于值的不可改变性，
            final修饰的引用类型变量是，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个毒对象，但是这个对象完全可以发生改变
        6.4.4 可执行宏替换的final变量
            在程序中使用final修饰的变量就相当于一个直接量，，，因为在编译中，用到这个变量的地方啊，都换成这个变量的值，，，
            但是在final修饰的变量不能在编译的时候确定下来，这个变量在内存中保存，所以他们不是相等的。
        6.4.5 && 6.4.6  final修饰的方法和类
            有这个修饰的方法，是不可以重写的，但是可以重载，但是在子类中，也是可以出现一模一样的方法，这个方法就是新方法，与父类的方法无关
            有这个修饰的类，是不可以让子类继承的，
        6.4.7 不可变类
            意思是：创建该类的实例后，该实例的实例变量是不可发生改变的。
            例如 Double d = new Double(45), 程序无法修改这个值，因此这个类没有提供方法
            下面就是创建不可变类的规则{
                1.使用private和final 修饰符来修饰该类的成员变量
                2.提供带参数的构造器，用于根据传入参数来初始化类里的成员变量
                3.仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，
                4.如果有必要，则重写object的hashcode和equals方法，，
            }
            在引用变量这个就有一个问题：当创建不可变类，如果它包含成员变量的类型是可变的，那么对象的的成员变量依然是可变的——————则这个不可变类是失败的.
        6.4.8 缓存实例的不可变类
            让数组充缓存池，来进行，练习
            **由于new构造器创建Integer对象不会启用缓存，因此性能较差，已经标记为过时。而使用valueof方法可以缓存对象。但是Integer的缓存数字是有范围的，不能盲目
    6.5 抽象类
        抽象方法只有方法签名，没有方法实现的方法。
        6.5.1 抽象方法和抽象类
            抽象方法必须在抽象类中，抽象类可以没有抽象方法。
            抽象方法和抽象类的规则{
                1、抽象类或者方法必须使用abstract修饰符来修饰，
                2、不能实例化
                3、抽象类可以包含成员方法，变量，构造器，初始化块，内部类，5种成分
                4、含有抽象的类，但没有完全实现父类包含的抽象方法，或实现了一个接口，但没有完全实现接口包含的抽象方法。只能被定义成抽象类
            }
            ****final和abstract 不能同时使用。即通俗来说：没有所谓的类抽象方法，，但是这两个可以修饰内部类共同。
        6.5.2 抽象类的作用
            抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板。子类在父类的抽象类的基础上进行扩展。
            使用模板的一些规则{
                1.抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给子类去实现
                2，父类中可能包含需要调用其他系列的方法，这些被调方法可以是父类或子类实现。
            }
    6.6 java9改进的接口
        6.6.1 接口的概念
            类一种实现体，而接口定义了一种规范，接口定义了某一批所需要遵守的规范
            类似的，软件的各模块更应该用这个面向接口的耦合，从而尽量降低各模块之间的耦合。
        6.6.2 接口中的定义
            用interface关键字来定义接口
            一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类
            接口中不能包含构造器和初始化块，因为接口是一种规范。
            而且在接口中的方法就是实例方法。而默认方法就是有方法体的实例方法。
            接口的成员变量模式是使用public static final 修饰的
        6.6.3 接口的继承
            接口完全支持多继承
        6.6.6 面向接口编程
            接口体现的是一种规范和实现分离的实际哲学，可以很多程度上降低耦合。
            有两中常用场景：简单工厂模式，命令模式
            代码中可以看到

            工厂模式：就是相当于插U盘读取文件一样，需要不同的文件就查不同的U盘，
            命令模式：某个方法在完成某个行为，但这个行为无法确定，，必须等到执行该方法的时候才能够确定，
                    比如：在处理数组的前提下，你想先排序还是什么都不想干，等等的操作结束后，才开始进行处理数组数据
                    就是方法与处理行为的分离
    6.7 内部类
        内部类不想是我在前面代码中写的一个class里面有两个类，其实这种类是没有关系的，他们是存在于一个文件里，但实际上不存在任何关系而已

        而内部类有以下的作用{
                内部类提供了更好的封装
                内部类成员可以访问外类的私有数据，而不是像其他封装一样，是通过方法进行调用的
                匿名内部类适合用于创建那些仅需要一次使用的类
            }
        而内部类也分静态内部类和非静态内部类，
        而内部类在编译后显示外部类名$内部类名.class


        但是重要一点；不容许外部类的静态成员中直接使用非静态内部类
        6.7.2 静态内部类
            通过static修饰的就是静态内部类，现在的类的成员变成类相关，而不是实例想关
        6.7.3 使用内部类
            定义类的作用就是定义变量，创建实例和作为父类被继承
            1.在外部类内部使用内部类
                唯一的区别就是不要在外部类的静态成员（包括静态方法和静态初始化模块）中使用非静态内部类，因为静态成员不能访问非静态成员
            2.在外部类以外使用非静态内部类
                语法格式是：outclass.innerclass varname
                由于非静态内部类的对象必须寄生在外部类的对象里，因此创建非静态内部类对象之前，必须先创建其外部类的对象
                语法格式： OuterInstance.new InnerConstructor()

                重要的规则就是： 非静态内部类的构造器必须通过其外部类对象来调用
            3.在外部类以外使用静态内部类
                语法格式：new Outclass.InnerConstructor()
        6.7.4 局部内部类
            局部内部类就相当于局部变量一样，是在方法体中，
        6.7.5 java8改进的匿名内部类
            匿名内部类只是用于一次性使用的，而且创建匿名内部类会立即创建一个实例，这个类定义立即消失，则不能重复使用
            从代码中看，匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类或实现一个接口

            当通过接口来实现内部类时，匿名内部类也不能显示创建构造器，因此匿名内部类只有一个隐式的无参数构造器，故new 接口名后 的括号里不能传入参数值

            重要的一点是：如果局部变量被匿名内部来访问时，那么该局部变量就相当于自动使用了final修饰
    6.8 java8新增的Lambda 表达式
        lambda 表达式支持将代码块作为方法参数，容许使用更简洁的的代码来创建只有一个抽象方法的接口（被称作为函数式接口）
        6.8.1 lambda 表达式入门
            lambda 的主要作用就是代替匿名内部类的繁琐语法
             他有三部分组成：形参列表，箭头，代码块
             代码中lambda的集中简化写法

        6.8.2 lambda 表达式与函数式接口
            表达式的类型，也被称为--目标类型--    而且目标类型必须是函数式接口

            在java中函数式接口必须要注解  @FunctionalInterface 注解，，，，说明这个接口是函数式接口，不然会报错的

            lambda表达式有两个限制：{
                表达式的目标类型必须是明确的函数式接口
                表达式只能为函数式接口创建对行啊。。只能实现一个方法
            }

            而lambda表达式的值可以赋给变量，方法，强制类型转换
            而在java.util.function 包下有大量的函数式接口，
        6.8.3 方法引用与构造器引用
            表达式中可以在代码块中使用方法引用和代码引用。{
                引用类方法，引用特定对象的实例方法，引用某类对象的实例方法，引用构造器
                具体的步骤可以再看，，用时可以补充。
            }

    6.9 枚举类
        枚举类使用enum关键字，枚举类也是一个特殊类，他不能显示继承其他父类也不能派生子类，，，但是它可以有构造器和成员变量和方法等等。
        枚举类的构造器只能private访问控制符，
        枚举类的所有实例必须要在枚举类的第一行累出，，
        values 方法可以遍历枚举值

        java.lang.Enum 提供了几个方法：{
            intcomparTo（E o） 该方法用于指定枚举对象比较顺序
            String name（）  返回此枚举实例的名称
            int ordinal  返回枚举值在枚举类中索引值
            String toString  返回枚举常量的名称
            public static <T extends Enum<T>> T valueof(Class <T> enumType,String name)   返回指定枚举类中指定名称的枚举值
        }
        6.9.3 枚举类的成员变量，方法和构造器
            枚举类的实例只能是枚举值，而不是随意的通过new来创建枚举类对象
            枚举类通常应该设计成不可变类，也就是说成员变量都应该使用private final 修饰 的，
        6.9.5 包含抽象方法的枚举类
            每一个枚举的实例都可以是一个类，，，他可以实现一个抽象方法，来完成用户的操作的问题。
    6.10 对象与垃圾回收
        垃圾回收机制具有如下的特点：
            垃圾回收机制只负责回收堆内存中的对象，不会回收任何的物理资源
            程序无法精确控制垃圾回收的运行，垃圾回收会在任何的时候进行
            在垃圾回收机制回收任何对象之前，总会先调用它的finalize方法，该方法可能使对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收
        6.10.1 对象在内存中的状态
            有三个状态：可达状态，可恢复状态，不可达状态。
                当然在可恢复状态的时候如果进行资源清理就必须finalize方法来判断这个引用是否可以到不可达的状态，
        6.10.2 强制垃圾回收
            强制垃圾回收：
                调用system类的gc静态方法
                调用Runtime对象的gc实例方法，runtime.getRuntime.gc
            当然这个不能用ide去明显的看出来，需要再命令端通过编译和运行才可以明确看出
        6.10.3 finalize方法
            finalize方法具有四个特点：
                永远不要主动调用某个对象的finalize方法，
                这个调用时不确定性的，
                jvm执行这个方法， 对程序不会产生什么异常，会继续运行。
        6.10.4 对象的软，弱和虚引用
            有四种引用方式：
                强，软，弱，虚（主要用于跟踪对象被垃圾回收的状态，不能单独使用，必须和引用队列ReferenceQueue联合使用）、
    6.11 修饰符的使用范围
        strictfp 关键字的含义是FP-strict 也就是精确浮点的意思
        native关键字是在java程序用c语言去实现，如果用了这个，，就没有扩平台的功能。

    6.12 java9的多版本JAR包，，，---------不参考。
