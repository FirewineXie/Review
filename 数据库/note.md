# 第一章

1. 数据库的四个基本概念
   - 数据 ： 是数据库中存储的基本对象，描述事物的符号记录
   - 数据库：是长期存储在计算机内，有组织的、可共享的的大量数据的集合
   - 数据库管理系统 ： 是位于用户和操作系统之间的一层数据管理软件
   - 数据库系统  ： 是有数据库、数据库管理系统、应用程序和数据库管理员 组成的存储、管理和维护数据的系统。
2. 数据管理技术的三个阶段
   1. 人工管理的阶段
   2. 文件系统阶段
   3. 数据库系统阶段
3. 数据库系统的特点：
   1. 数据结构化
   2. 数据的共享性高，冗余度低且易扩充
   3. 数据独立性高
   4. 数据由数据库管理系统统一管理和控制
      - 数据的安全性
      - 数据的完整性
      - 并发控制
      - 数据库恢复
4. 数据模型
   1. 两类数据模型
      1. 概念模型
      2. 逻辑模型和物理模型
   2. 常用的数据模型
      1. 层次模型
      2. 网状模型
      3. 关系模型
      4. 面向对象数据模型
      5. 对象关系数据模型
      6. 半结构数据模型
   3. 在关系模型的数据结构中
      1. 关系 ： 一个关系就是对应的一张表
      2. 元祖 ： 表中的一行
      3. 属性 ； 表中的一列
      4. 码 ： 表中的某个属性组，它可以唯一确定一个元组
      5. 域 ： 域是一组具有相同数据类型的值得集合
      6. 分量 ： 元祖中的一个属性值
      7. 关系模式 ： 对关系的描述
5. 关系的完整性
   1. 约束的条件：
      - 实体完整性
      - 参照完整性
      - 用户定义的完整性
6. 数据库的模式
   1. 三级模式结构
      - 模式
        - 又是逻辑模式，是数据库中全体数据的逻辑结构和特征的模式，是所有用户的公共数据视图
      - 外模式
        - 是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图
      - 内模式
        - 存储模式，一个数据库只有一个内模式，他是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式
   2. 两层映像
      1. 外模式/模式映像
         1. 保证了数据与程序的独立性
      2. 模式/内模式映像
         1. 保证了数据的物理独立性

# 第二章

1. 笛卡尔积
   1. 是域上面的一种集合运算
   2. 域是一组具有相同数据类型的值得集合
   3. 候选码 ： 某一属性组的值能唯一的标识一个元祖，而其子集不能
2. 关系完整性
   1. 实体完整性规则
      - 若属性（指一个或一组属性）A是 基本关系R 的主属性，则A不能为空值。
      - 就是主键的约束
   2. 参照完整性
      - 若属性 F 是基本关系R 的外码，它与基本关系S的主码 Ks 相对应，则对应R 的每一个F 对应的值 必须 或者空值，等于主码值，空值和非空值
      - 就是外键的约束
   3. 用户定义的完整性
      - 就是针对某一具体关系数据库的约束条件，他反映某一具体应用所涉及的数据必须满足的语义要求

# 第四章

1. 数据库的安全性 
   - 安全性是指： 保护数据库以防止不合法使用所造成的数据泄露、更改或泄露
2. 数据库安全性控制
   1. 用户身份鉴别
   2. 存取控制
   3. 自主存取控制方法
      1. 是用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户还可以将其拥有的存取权限转授他人
   4. 授权：授予与收回
   5. 数据库角色
   6. 强制存储控制方法
      1. 是指系统为保证更高程度的安全性，按照标准中安全策略的要求所采取的强制存取检查手段
      2. 是对数据本身进行密级标记，，来控制数据复制等
   7. 视图机制
   8. 审计
   9. 数据加密
3. 自主存取控制和强制存储控制的区别
   1. DAC的数据存取权限由用户控制，系统无法控制；MAC安全等级由系统控制，不是用户能直接感知或进行控制的。 

# 第五章

1. 数据库完整性
   - 是指 数据的==正确性==和==相关性==
   - 数据的完整性 ： 
     - 是为了 防止 数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据
   - 数据的安全性：
     - 是保护数据防止恶意破坏和非法存取
2. 实体完整性
   -  检查主码值是否唯一，如果不唯一拒绝插入和修改
   - 检查主码的各个属性是否为空，主要有一个为空就拒绝插入和修改，从而保证了数据的完整性
3. 参照完整性
   - 检查 哪些列为外码
   - 违约处理：
     -  破坏参照完整性 （参照表）： 拒绝
     - 破坏参照完整性(被参照表) ： 拒接、级联删除、设置为空值
4. 用户定义的完整性
   1. 就是针对 某一具体应用的数据必须满足的语义要求
   2. 属性上的约束条件
      - 列值非空
      - 列值唯一
      - 检查列值是否满足一个条件表达式
   3. 违约处理 ： 
      1. 拒绝执行
   4. 元祖上的约束条件
      1. 与上面类似



# 第六章

在这章里，主要的是范式

1. 第一范式（1NF）
   1. 一个二维表，关系要符号一个最基本的条件： 每一个分量必须是不可分的数据项，满足这个条件才是第一范式
2. 关系数据库 的关系是要满足 一定要求的，满足不同程度要求 的为不同范式。



1. 规范化 ： 一个低一级范式的关系模式通过模式分级可以转换为若干个高一级范式的关系模式的集合，就是规范化
2. BCNF 特殊的第三范式（或者可以说是规范化的第三范式）
   1. 一个满足BCNF 的模式的条件：
      - 所有非住属性对每一个码都是完全依赖函数
      - 所有主属性对每一个不包含它 的码也是 完全依赖函数
      - 没有任何属性完全函数依赖于非码的任何一组属性



# 第七章

1. 数据库设计 
   1. 是指 对于一个 给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的需求，
2. 数据库设计的基本步骤：
   - 需求分析
   - 概念结构设计
     - E-R图
   - 逻辑结构设计
     - 数据模型
       - 就是 根据 E-R 图 建表，
   - 物理结构设计
     - 存储安排
     - 存储方法选择
     - 存取路径建立
   - 数据实施
     - 创建数据库，
     - 装入数据，并试运行
   - 数据库运行和维护
3. E-R图
   1. 实体型 用==矩形==表示，矩形框内写明实体名
   2. 属性用==椭圆型==表示，并用无向边 将其与相应的实体型连接起来
   3. 联系用==菱形==表示， 菱形框内 写明联系名，并用无向边 分别与其有关实体型连接起来，同时在**无向边旁表上==联系的类型==**



# 第十章

1. 事务 ： 
   1. 是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的单位。
   2. 事务的四个特性：
      - 原子性，
      - 一致性
      - 隔离性
      - 持续性
2. 故障的分类：
   - 系统故障
   - 介质故障
   - 计算机病毒
3. 事务故障的恢复
   1. 反向扫描日志文件，查找该事务的更新操作
   2. 对该事务的更新操作执行逆操作
   3. 继续反向扫描日志文件
   4. 如此处理下去，直到此事务的开始标记，事务故障恢复
4. 系统故障的恢复
   1. 正向扫描日志文件。找出故障发生前已经提交的事务，也找出没有完成提交的事务标记为撤销
   2. 对撤销队列 的各个事务进行撤销处理(反向扫描日志文件，恢复数据)
   3. 对重做队列的事务进行重做处理
5. 介质故障的恢复
   1. 重装数据库，然后重做已完成的事务



## 并发控制

1. 活锁

   1.  事务被抢占资源，永远等待
   2. 解决办法：
      1. 采用先来先服务的策略

2. 死锁

   1. 事务 被互相 影响，两个事务永远不能结束，形成死锁

   2. 解决办法：

      1. 选择代价最小的事务，将其撤销，释放此事务持有的所有的锁

   3. 预防死锁的办法：

      1. 一次封锁法

         - 要求每个事务必须一次将所有要使用的数据全部加锁，否则不能继续执行

      2. 顺序封锁法

         - 预先对数据规定一个封锁顺序，所有事务按照这个顺序实施封锁

   4. 死锁的诊断
      -  超时法
      - 事务等待图法      

3. 并发调度的可串行性
   1. 可串行调度
      - 定义 ： 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行这些事务的结果相同
4. 两段锁协议
   1. 采用 这个协议来 实现并发调度的可串行性
   2. 是指所有事务必须分两个阶段对数据项加锁和解锁
   3. 在释放一个封锁之后，事务不再申请和获得任何其他封锁
   4. 第一阶段为 扩展阶段
   5. 第二阶段为 收缩阶段