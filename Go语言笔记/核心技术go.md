# go 核心技术

## 工作区和GOPATH

- GOROOT ： go语言安装根目录的路径，也就是go语言的安装路径
- GOPATH ： 若干工作区目录的路径，是自己行医的工作空间
- GOBIN：go程序生成的可执行文件 的路径

1. 设置gopath

   现在来说，无意义，采用模块化开发，类似于maven 将依赖归于一个文件夹下，不需要重复下载



### 命令源码文件

> 源码文件分为三种：
>
> 1. 命令源码文件
> 2. 库源码文件
> 3. 测试源码文件

## container 容器

> 里面包含链表，循环列表ring



go中的 数据结构或者变量 都是具有初始化默认值

`延迟初始化`： 是在要调用的时候，才进行初始化





## 字典的操作和约束

go语言的字典类型其实一个哈希表hash table 的特定实现





## 通道

> Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）

**一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符`<-`。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。**





通道的发送和接收基本特性如下。

1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
2. 发送操作和接收操作中对元素值的处理都是不可分割的。
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。







通道进入的值，是副本，



对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发panic。但是通道一旦关闭，再对它进行发送操作，就会引发panic。





单通道的作用：

`单向通道最主要的用途就是约束其他代码的行为`

```go
func SendInt(ch chan<- int) {
	ch <- rand.Intn(1000)
}
```

这个函数只接受一个chan<- int类型的参数。在这个函数中的代码只能向参数ch发送元素值，而不能从它哪里接收元素值。就是约束函数行为的作用

```go
type Notifier interface {
	SendInt(ch chan<- int)
}
```

约束一般出现在接口类型声明中的某个方法定义上。

`Notifier`接口中的`SendInt`方法只会接受一个发送通道作为参数，所以，在该接口的所有实现类型中的`SendInt`方法都会受到限制。这种约束方式还是很有用的，尤其是在我们编写模板代码或者可扩展的程序库的时候。

传送可以是双向通道，程序会自动将转换函数所需要的单通道

**问题2：`select`语句的分支选择规则都有哪些？**

规则如下面所示。

1. 对于每一个`case`表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果`case`表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的`case`表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。

   

2. `select`语句包含的候选分支中的`case`表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在`select`语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。

   

3. 对于每一个`case`表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该`case`表达式的求值就是不成功的。在这种情况下，我们可以说，这个`case`表达式所在的候选分支是不满足选择条件的。

   

4. 仅当`select`语句中的所有`case`表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么`select`语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，`select`语句（或者说它所在的goroutine）就会被唤醒，这个候选分支就会被执行。

   

5. 如果`select`语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使`select`语句是在被唤醒时发现的这种情况，也会这样做。

   

6. 一条`select`语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。

   

7. `select`语句的每次执行，包括`case`表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的`case`表达式以及分支中，是否包含并发不安全的代码了。

## 函数用法

函数是一等公民

函数不但可以用于封装代码，分隔功能，解耦逻辑，还可以化身普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等。

更深层次的含义： 函数值可以由此成为能够随意传播的独立逻辑组件（或者功能模块）



### 高阶函数

> 满足条件：
>
> 1. 接收其他的函数作为参数传入
> 2. 把其他的函数作为结果返回
>
> 三者只需要满足一个，就是高阶函数，也是函数式编程中的重要概念和特征

**函数类型属于引用类型，他的值可以为nil，而这种类型的恰恰就是nil**

> ==卫述语句==是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块执行的语句。在Go语言中，if 语句常被作为卫述语句。

把其他函数作为结果返回

```go
package main

import (
	"errors"
	"fmt"
)

/*
@Time : 2020/10/17 17:22
@Author : Firewine
@File : main
@Software: GoLand
@Description:
*/
type operate func(x, y int) int
type calculateFunc func(x,y int) (int ,error)

func main() {
	x, y := 56, 78

	op := func(x ,y int) int {
		return y * x
	}
	add, _ := genCalculator(op)
	result, err := add(x, y)
	fmt.Printf("The result: %d (error: %v)\n", result, err)
}
// 闭包函数，
// 变量op 既不代表它的任何参数或结果也不是他自己声明的，而是定义他的genCalculator函数的参数，所以是一个自由变量
//
func genCalculator(op operate) (calculateFunc, error) {
	return func(x int, y int) (int, error) {
		if op == nil {
			return 0, errors.New("invalid operation")
		}
		return op(x, y), nil
	}, nil
}


```

genCalculaaror 根据自由变量，来确定这个函数功能的作用，不同的op提供不同的功能





## 接口

> 接口类型声明中的这些方法所代表的就是该接口的方法集合。一个集合的方法集合就是它的全部特征

如何判断是否实现某个接口类型中的某个方法：

1. 两个方法的签名需要完全一致，
2. 两个方法的名称要一样

==如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。==

### 知识扩展

1. 接口变量的值什么情况下才真正为nil

   对于引用类型的变量，他的值是否为nil 完全取决于我们赋给它了什么 

2. 使用接口，要先弄清楚的是，接口变量的动态值，动态类型和静态类型都代表了什么

3. 接口变量的值并不等同于这个可被称为动态值的副本 。它会包含两个指针，一个指针指向动态值，一个指针指向类型信息

## 关于指针的有限操作

###  值是不可以寻址的

- 常量的值
- 基本类型的字面值
- 算数操作的结果值
- 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可以寻址的
- 对字符串变量的所有表达式和切片表达式的结果值
- 对字段变量的索引表达式的结果值
- 函数字面值和方法字面值，以及对他们的调用表达式的结果值
- 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值
- 类型转换表达式的结果值
- 类型断言表达式的结果值
- 接收表达式的结果值

解析

函数在Go语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但是，这样的函数和方法都是不可寻址的。一个原因是函数就是代码，是不可变的。

另一个原因是，拿到指向一段代码的指针是不安全的。此外，对函数或方法的调用结果值也是不可寻址的，这是因为它们都属于临时结果

总结

1. **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
2. 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
3. 若拿到某值的指针可能会破坏程序的一致性，那么就是**不安全的**，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。

#### unsafe.Pointer 操纵可寻址的值

可以绕过go语言的编辑器和其他工具的重重检查，并达到嵌入内存修改数据的目的，但是这不是安全的操作，可能存在安全隐患。

尽量是使用api接口去编写程序



## go语句及其执行规则

**不过别担心，Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器。**

这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）。

```go
func main() {
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
}
// 为什么，没有数据打印出来
// 首先 主goroutine  已经运行完了，，线程还没有线程，就已经停止了
// 要想打印出来东西，必须要让主线程等待子线程运行完成

```

### 知识扩展

#### 怎么才能让主goroutine 等待其他的goroutine

1. 通过主线程暂时休眠，但是休眠多长时间确实不知道的
2. 特殊的点，空结构体 **struct{}** 是内存空间是0字节，在整个程序里面只有一份，但是可以无数次使用，却是同一个值



#### 怎么样启动有顺序的goroutine 运行

```go

for i := 0; i < 10; i++ {
	go func(i int) {
		fmt.Println(i)
	}(i)
}

// 将 i 传入 协程里，确保每个goroutine 都可以拿到一个唯一的整数，，
//就是遍历，先出来才会给协程，协程才开始云心
```

##  对于错误的处理方法

### 惯用法

1. 对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch 语句来判断
2. 对于已有相应变量且类型相同的一些列错误值，一般直接使用判等操作来判断
3. 对于没有相应变量且来兴位置的一些列错误值，只能使用其错误信息的字符串表示形式来做判断

```go
switch err := err.(type) {
	case *os.PathError:
		return err.Err
	case *os.LinkError:
		return err.Err
	case *os.SyscallError:
		return err.Err
	case *exec.Error:
		return err.Err
	}
	return err



if err == nil {
		fmt.Println("nil error")
		return
	}
	err = underlyingError(err)
```



## panic 函数 recover 函数与defer 语句

### panic

这种异常 只会在 程序运行的时候被抛出来

一般程序，没有对错误进行处理，那么panic 就会停止程序

####  从panic 被引发到程序终止运行的大致过程是什么

> 某个函数中的某行代码有意或无意地引发了一个panic。这时，初始的panic详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。

### 知识扩展

1. 怎么样让panic 包含一个值，以及应该让它包含什么样的值

   在调用`panic`函数时，把某个值作为参数传给该函数就可以了。由于`panic`函数的唯一一个参数是空接口（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。

2.  怎样施加应对panic的保护措施，从而避免程序崩溃？

   Go语言的内建函数`recover`专用于恢复panic，或者说平息运行时恐慌。`recover`函数无需任何参数，并且会返回一个空接口类型的值

3. defer 函数调用都会在它即将结束执行的那一刻执行，

4. 如果一个函数中有多条`defer`语句，那么那几个`defer`函数调用的执行顺序是怎样的？

   在同一个函数中，`defer`函数调用的执行顺序与它们分别所属的`defer`语句的出现顺序（更严谨地说，是执行顺序）完全相反





## 测试的流程及规则

> 分为三类 ： 功能测试test，基准测试benchmark 也叫性能测试
>
> 示例测试example

一般测试文件是以源码文件为主，文件名称是源码文件后面跟_test为后缀。

### go语言对测试函数的名称和签名都有哪些规定

- 对于功能测试函数来说，其名称必须以`Test`为前缀，并且参数列表中只应有一个`*testing.T`类型的参数声明。
- 对于性能测试函数来说，其名称必须以`Benchmark`为前缀，并且唯一参数的类型必须是`*testing.B`类型的。
- 对于示例测试函数来说，其名称必须以`Example`为前缀，但对函数的参数列表没有强制规定

## sync.Mutex 与sync.RwMutex

> sync 是同步的意思
>
> 这个与大多数语言一样，采用共享数据的方式来传递信息和协调线程运行的做法更加主流，

一旦数据被多个线程共享，那么就很可能会产生争用和冲突。这种情况也被称为**竞态条件** ，这往往会破坏共享数据的一致性

共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。

概括来讲，**同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。**





在go语言中，最重要且最常用的同步工具当属互斥量mutex



使用 mu.lock,  mu.unlock  进行互斥锁



#### 使用互斥锁的注意事项

1. 不要重复锁定互斥锁；
2. 不要忘记解锁互斥锁，必要时使用`defer`语句；
3. 不要对尚未锁定或者已解锁的互斥锁解锁；
4. 不要在多个函数之间直接传递互斥锁。



而产生死锁，程序必然崩溃

## sync.cond

条件变量怎么样与互斥锁配合使用

答 ： 条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的

条件变量提供的方法有三个：等待通知，单发通知和广播通知

```go
var mailbox uint8
var lock sync.RWMutex
sendCond := sync.NewCond(&lock)
recvCond := sync.NewCond(lock.RLocker())
```

