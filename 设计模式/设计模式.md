#  理解软件编程背后的系统化思维

## 学习思维：如何学好设计模式

> 1. 先于搞清楚设计模式能解决那些范围的问题，才能正确的时候设计模式
> 2. 设计模式解决的是`可复用`的设计模式
> 3. `设计模式的提出就是为了解决限定领域的有限问题`
> 4. 好的设计从来不是看用的模式有多少，而是看如何合理利用模式的设计思想，以及如何利用模式解决真实的问题。

## 组合思维：Unix哲学

> 1. Unix 设计哲学，主张组合设计，而不是单体设计；主张使用集体智慧，而不是某个人的特殊智慧
> 2. `简单完备性`,`组合思维`,`数据驱动`

1. 保持简单清晰性，能提升代码质量（`一个程序只做一件事，并做的很好`）
2. 借鉴组合理念，有效应对多变的需求
3. 重拾数据思维，重构优化程序设计
4. `在Unix 的理念中，编程中重要的是数据结构，而不是算法`
5. 数据驱动编程： 会把代码和代码作用的数据结构分开，这样在改变程序的逻辑时，就只要编辑数据结构，而不需要修改代码了。



## 分层思维： 为什么要做代码分层架构

> 1. 功能性需求 ： 一个程序能为用户做些什么，
> 2. 非功能需求： 指功能性需求以外的其他必要需求，比如性能、安全性等等。





### 代码分层架构是什么

#### 软件部署分层

![image-20210621192559637](img/image-20210621192559637.png)

> 软件分层架构是通过层来隔离不同的关注点（变化相似的地方），依次来解决不同需求变化的问题，使得这种变化可以被控制在一个层里。

#### 应用程序里的分层架构

![image-20210621192724992](img/image-20210621192724992.png)

#### 什么是代码分层

> 代码分层架构 ： 就是将软件“元素”（代码）按照“层”（代码关系）的方式组织起来的一种架构
>
> 分层架构核心的原则是：当请求或数据从外部传递过来后，必须是从上一层传递给下一层。



##### 代码分层能解决什么问题

- 快速拆解功能问题
- 提升代码的可扩展性



#### 解决上面的两个问题

> 1. 功能性需求： 将复杂问题分解为多个容易解决的子层问题
> 2. 非功能性需求，可以提升代码可扩展性





## 工程思维： 利用软件工程解决开发难题



### 保证软件交付的效率和可靠性

- 从计算机科学角度看，软件开发需要关注软件本身运行的原理
- 从工程角度来看，软件开发更多的是关注如何为用户实现价值

`在软件开发时，我们总是容易太过于关注局部，而没能跳出剧本看整体`





### 什么是软件工程

> 软件开发过程 = 定义与分析 + 设计+ 实现 + 测试 + 交付 + 维护
>
> 软件工程 =  过程 + 方法 + 工具





## 对象思维： 面向对象编程有哪些优势

> 面向对象技术  就是为了 解决软件的大规模可扩展性问题
>
> 编程范式是一种根据编程语言的功能对编程语言进行分类的方法，它不针对具体的某种编程语言。

![image-20210621194505367](img/image-20210621194505367.png)



#### 面向对象编程优势

- 模块化更适合团队敏捷开发
- 对象结构更能提升代码重用性、可读性
- 组合和聚合思想让代码演进更重视组件化





## 迭代思维：如何高效编程



### 什么是高效编程

> 1. 写代码的效率只是整体编程效率的一部分
> 2. 高效编程`其实就是一种高效的工作流`



### 如何高效编程？

> `高效编程 = 原则 * 工具 * 编码 * 反馈 * 迭代`

#### 1. 建立原则

> 原则能让在你编程时，不会轻易遗忘一些重要的事情

1. 第一条原则：问题到你为止
   1. 无论是不是你的问题，你都应该尝试去终结这个问题
2. 多读、多写代码
   1. 多读别人的代码
   2. 多写自己的代码
3. 打破砂锅问到底



### 2. 打磨工具

> 时刻关注前沿，，一方面可以熟悉组件特性，另一方面是培养你编程上多准备的习惯。



### 3. 实践编码

1. 靠运气编码（lucky）
2. 重复硬编码（非常紧急的事情）
3. 写PPT，开会



### 4. 及时反馈

### 5. 迭代更新

> 1. 每一个迭代都应有输入，处理和输出
> 2. 记录版本
> 3. 不断更新



# 从设计原则中领悟编程技能

## 单一原则： 如何跳出错误抽象的误区

> 1. 面向对象原则（SOLID）
> 2. 简单原则（KISS）
> 3. 单一原则（DRY）
> 4. 最少原则（LoD）
> 5. 分离原则（Soc）

`为什么会选择困难，有的原则之间是相互冲突的，而有的原则之间又是彼此重复的`



### DRY原则

> 不要重复自己

####  陷阱一 ： 随时关心代码重用性

> 随时在意有没有写重复代码；
>
> 随时在意代码能不能重用；
>
> 随时在意有没有因为重复而浪费时间。

三种代码重复类型

> 功能需求重复
>
> 实现逻辑重复
>
> 执行调用重复



`简单来说，你应该先写出可以运行的代码，再考虑是否需要重用代码。`



#### 陷阱二 ： 过度设计

> 是因为我们总是期望通过现在的灵活设计来避免未来需求变化后的重复设计与编码。这样做的话，确实特别符合 DRY 原则的理念。但实际上，需求的变化方向是不可预测的。

`抓住上下文，适度设计`



#### 陷阱三 ： 写一次性代码

> 1. 硬编码
> 2. 复制粘贴编程

`坚持写易懂的代码`

1. 易懂的代码不是指容易、简单的代码
2. 易懂的代码能借用语言特性来发挥优势
3. 易懂的代码需要遵从一定的代码规范
4. 易懂的代码要能正确运行
5. 始终牢记 ——易懂的代码不是你告诉计算机怎么做的答案，而是告诉另一个程序员你想要计算机做什么的意图。



## 简单原则：如何写出简单代码

> 简单原则：KISS原则



### 为什么要让代码保持简单

1. 防止代码腐坏
2. 减少时间成本投入
3. 快速迭代，拥抱变化



### 理解代码中的简单？

> 误解： `简单分析 + 简单设计 + 简单编程 = 简单产品`
>
> `编程的本质就是控制复杂度`

1. 简单≠简单设计或简单编程
2. 简单≠数量少
3. 简单≠过度简洁

#### 简单是什么

1. 简单应是坚持实践
2. 简单是尽量简单，但又不能太简单。换句话说，就是要管理合适的代码上下文环境，并且在边界范围内以“最少知识”的方式构建程序，满足要求即可，保持一定的克制。
3. 简单应该是让别人理解代码逻辑时更简单

### 如何写出简单代码

#### 四不要：

1. 不要长期进行补丁式的打码
2. 不要炫耀编程技巧
3. 不要简单编程（硬编码、一次性编码、复制粘贴编码、面向搜索编程都是简单编程）
4. 不要过早优化

#### 四要：

1. 定期做Code Review
2. 要选择合适的编码规范
3. 要适时重构
4. 要有目标地逐渐优化



### 扩展： YAGNI原则

> `不要写“将来可能需求，但现在却用不上”的代码`
>
> YAGNI 原则能够帮助我们更好地实现 KISS 原则



## 最少原则：如何实现“最少知识”代码

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

> 上述代码存在依赖每一个细节，不仅增加了耦合，也使代码结构僵化

迪米特法则正是为了避免对象间出现这样过多的细节依赖而被提出来。

### 什么是迪米特法则

> 1. 一个类只应该与它直接相关的类通信
> 2. 每一个类应该知道自己需要的最少知识

换句话说，在面向对象编程中，它要求任何一个对象（O）的方法（m），只应该调用以下对象：

- 对象（O）自身；
- 通过方法（m）的参数传入的对象；
- 在方法（m）内创建的对象；
- 组成对象（O）的对象；
- 在方法（m）的范围内，可让对象（O）访问的全局变量。



### 应用法则需要注意的问题

1. 容易为了简化局部而忽略整体的简化
2. 拆分时容易引入很多过小的中间类和方法
3. 不同模块之间的消息传递效率可能会降低



### 扩展 ： 面向切面编程AOP

> **面向切面编程，简单来说，就是可以在不修改已有程序代码功能的前提下给程序动态添加功能的一种技术**
>
> 迪米特法则是在**程序设计时（静态）** 降低代码耦合的方法的话
>
> 面向切面编程就是在**程序运行期间（动态）** 降低代码耦合的方法





## 表达原则： 如何让源码成为一种逻辑线索



### 为什么要提升源代码的可读性

1. 更易于维护
2. 更易于重构
3. 更易于测试
4. 更易于应用设计模式



### 如何写出有“逻辑线索”的源代码

1. 代码表现形式 ： 在命名、代码格式、注释等方面的改进
2. 控制流和逻辑：尽量分离控制流和逻辑，让代码变得更容易理解
3. 惯性思维：找出长犯的一些惯性思考方式并逐一改进。
   1. 避免一次性代码
   2. 避免复制粘贴代码
   3. 避免写超长代码
   4. 避免过度简化命名和表达式
   5. 避免写“是什么”的注释



## 职责原则：如何在代码设计中实现职责分离

### 高内聚、低耦合： 职责分离的目标

![image-20210622115209183](img/image-20210622115209183.png)

![image-20210622115222534](img/image-20210622115222534.png)

`内聚本质上表示的是系统内部的各个部分对同一个问题的专注程度，以及这些部分彼此之间联系的紧密性`

`职责分离就是将不同变化原因引起的类或方法修改行为拆分到不同类或方法里面去`

### 职责分离的重要性

1. 直接对问题进行对象建模，方便理清构建逻辑
2. 将问题分解为各种职责，更有利于系统的测试、调试和维护
3. 提高系统的可扩展性

### 职责分离的时机

1. 命名太过于笼统
2. 改动代码后的测试规模很大
3. 类和方法过大



### 如何通过职责分离实现高内聚

> 实现职责分离的核心技巧就在于寻找互相不重合的职责





## 面向对象原则： 面向对象编程框架到底长什么样



### 五大设计原则概览



1. SRP  ： 单一职责原则，意思是对象应该仅具有一种单一的功能
2. OCP： 开闭原则，也就是程序对扩展开发，对于修改关闭
3. LSP： 里式替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的
4. ISP： 接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口
5. DIP： 依赖反转原则： 该原则认为一个方法应该遵从“依赖于抽象而不是一个实例”



#### 单一职责原则

> 对一个类而言，应该仅有一个引起它变化的原因

理解SRP 时，抓住重点`职责是否具有唯一性`



#### 开闭原则

> 你在设计或修改程序代码时，应该尽量去扩展原有程序，而不是修改原有程序
>
> **开闭原则更像是一个框架的设计原则，而不是具体的业务编码技巧**

```java
public abstract class Demo  extends AbstractDataSource {

    private int readDsSize;



    @Override

    public Connection getConnection() throws SQLException {

        return this.determineTargetDataSource().getConnection();

    }

    @Override

    public Connection getConnection(String username, String password) throws SQLException {

        return this.determineTargetDataSource().getConnection(username, password);

    }

    protected DataSource determineTargetDataSource() {

        if (determineCurrentLookupKey() && this.readDsSize > 0){

            //读库做负载均衡（从库）

            return this.loadBalance();

        } else {

            //写库使用主库

            return this.getResolvedMasterDataSource();

        }

    }

    protected abstract boolean determineCurrentLookupKey();



    //其他代码省略



}

```



#### 里氏替换原则

> 原意： 子类应该能够完全替换掉它的基类。换句话说，在进行代码设计时，应该尽量保持子类和父类方法行为的一致性

LSP 的本质就是`通过继承实现多态行为`



#### 接口隔离原则

> 适合接口的设计原则
>
> 原意 ： 不应该强迫用户依赖于他们不用的方法

`好的接口隔离不是只考虑一个接口中方法的隔离，还应该多考虑整体系统中的职责`

#### 依赖反转原则

> 原意 ： 
>
> 1. 高层模块不应该依赖底层模块，二者都应该依赖于抽象
> 2. 抽象不应该依赖于细节，细节应该依赖于抽象。
>
> 通俗来说： 寻找好的抽象。这里的抽象不是简单指java中的interface，而是指可以创建出固定却能够描述一组任意个可能行为的抽象体。
>
> 而好的抽象 就是指 **具备一些共性规律并能经得起事件检验的抽象**

`要尽量通过寻找好的抽象来解决大量重复工作的效率问题`



#### 五大设计原则之间的关系

![image-20210622155641139](img/image-20210622155641139.png)



## 反转原则 ： 如何减少代码间的相互影响

>适用于场景：
>
>1. 一个平台系统，需要接入各种各样的业务系统，而这些业务系统都有自己的账号体系，平台需要兼容这些系统的账号体系，于是代码中出现了大量依赖于各种账号体系的代码。
>2. 一个网站页面，需要越来越多的频道（首页、搜索、分类等），不同频道对应的个性化需求各不相同，并且各种页面的标准组件、布局、模板，以及与后端交互框架也各不相同，不同体系的代码依赖非常紧密。
>3. 一个通用的订单处理平台，各条业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多，代码里随处可见定制化的需求代码。



### DIP ： 统一代码交互标准

> 这和浏览器的使用原理也很类似。浏览器（对应商品买家）并不依赖于后面的 Web 服务器（对应商品卖家），其只依赖于 HTTP 协议（对应银行），只要我们遵循 HTTP 协议就能在浏览器中提供很多丰富的 Web 功能，而不必针对特定的浏览器定制开发。



`依赖反转原则DIP 就是一种统一代码交互标准的软件设计方法`



#### 理解DIP 这个定义：

1. 首先，定义中的高级组件和低级组件，主要对应的是调用关系上的层级
2. 其次，高级组件和低级组件都应依赖抽象，是为了消除组件间变换对对方造成的影响，换句话说，抽象是一种约束，让高级组件或低级组件不能太随意的变动。
3. 最后，抽象不应该依赖实现，实现应该依赖抽象。



#### 为什么要使用DIP

1. 可以有效的控制代码变化的影响范围
2. 可以使代码具有更强的可读性和可维护性



### 怎么做： 给具体实现抽象标准接口



实现一个功能： 读取字符串后，再输出显示

为了方便你理解组件间的作用关系，我们下面将 StringReader 类和 StringWriter 类统称为低级组件，StringProcessor 称为高级组件，这样能更清楚地了解每个设计选择是如何影响整体设计的。

#### 设计一： 低级组件和高级组件都作为具体类放在同一包中

```java
public class StringProcessor { //具体类

    private final StringReader stringReader; //具体类

    private final StringWriter stringWriter; //具体类

    //通过构造函数来注入依赖组件

    public StringProcessor(StringReader stringReader, StringWriter stringWriter) {

        this.stringReader = stringReader;

        this.stringWriter = stringWriter;

    }

    public void readAndWrite() {

        stringWriter.write(stringReader.getValue());

    }

    //测试用例

    public static void main(String[] args) {

        StringReader sr = new StringReader();

        sr.read("1111111");

        StringWriter sw = new StringWriter();

        StringProcessor sp = new StringProcessor(sr,sw);

        sp.readAndWrite();

    }

}

```

> 基本设计方法，逻辑简单，编码容易，缺点 是程序高度耦合，任何一个低级组件的修改都会影响高级组件

#### 设计二： 低级组件具体类与高级组件接口实现类放在同一程序包中

```java
public interface StringProcessor {

    void readAndWrite(StringReader stringReader, StringWriter stringWriter);

}

```

```java
public class StringProcessorImpl implements StringProcessor {

    //通过接口传参来注入依赖组件

    @Override

    public void readAndWrite(StringReader stringReader, StringWriter stringWriter) {

        stringWriter.write(stringReader.getValue());

    }

    public static void main(String[] args){

        StringReader sr = new StringReader();

        sr.read("222222");

        StringWriter sw = new StringWriter();

        StringProcessor sp = new StringProcessorImpl();

        sp.readAndWrite(sr,sw);

    }

}

```

> 常见的误区之一 ： 只要有组件有接口就代表一定可复用
>
> 实际上 ，高级组件还是直接依赖于低级组件



#### 低级组件接口类与高级组件接口实现类放在同一程序包中

```java
public interface StringReader {

    void read(String path);

    String getValue();

}

public interface StringWriter {

    void write(String value);

}

```

```java
public class StringProcessorImpl implements StringProcessor {

    //StringReader 是接口

    //StringWriter 是接口

    @Override

    public void readAndWrite(StringReader stringReader, StringWriter stringWriter) {

        stringWriter.write(stringReader.getValue());

    }

    public static void main(String[] args) {

        StringReader sr = new StringReaderImpl();

        sr.read("333333");

        StringWriter sw = new StringWriterImpl();

        StringProcessor sp = new StringProcessorImpl();

        sp.readAndWrite(sr,sw);

    }

}

```

> 此时，StringProcessor、StringReader 和 StringWriter 都依赖于抽象，整体组件的逻辑控制权真正发生了变化，我们通过抽象化组件之间的交互，已经实现了从上到下的依赖关系的反转。
>
> 过去，StringProcessor 依赖于 StringReader 和 StringWriter 的具体实现，而现在则是 StringProcessor 来定义一组抽象规则，由 StringReader 和 StringWriter 来依赖。



#### 设计四： 低级组件接口类与高级组件接口类放在不同包中

```java
public class SPTest {

    @Resource

    private StringProcessor sp;

    @Resource

    private StringReader sr;

    @Resource

    private StringWriter sw;

    public void main(String[] args) {

        sr.read("444444");

        sp.readAndWrite(sr,sw);

    }

}

```

> 对于 StringReader 和 StringWriter 的实现这时就变成了“黑盒”，换句话说，对于使用者来说，我们可以完全不用关心  StringReader 和 StringWriter 是如何实现的，实现可以是 JDK  原生实现，可以是第三方的包实现，也可以是我们自行实现的，只要低级组件按照抽象约定的提供读写功能即可。

`只要是面向对象编程的语言，就能够用于这个四个思路实现DIP`



### 扩展Ioc ,DI ,IOC 容器与DIP 的区别

DI —— 依赖注入

IoC——控制反转

Ioc容器



#### 控制反转

> 是一种设计原则（也有人将其称为设计模式）。顾名思义，它用于反转设计中各种组件的控制关系，以实现松耦合。在这里，控制是指对象除自身主要职责以外的任何其他职责，通常包括对应用程序流的控制，以及对象的创建或子对象的创建、绑定的控制。
>
> 比如，你要开车去上班，这意味着你要控制一辆汽车，而 IoC 的理念是反转你的控制，你不用自己开车而是选择打车，让出租车师傅带你去上班，这时你的控制就发生了反转，出租车师傅专注于开车，而你专注于上班。



#### 依赖注入

> 简单来说，**它允许在类之外创建依赖对象，并通过不同方式将这些对象提供给类**。一般来讲，主要有三种方式来注入类：通过构造函数、通过属性和通过方法。



#### Ioc容器

> **IoC 容器（又叫作 DI 容器），是用于实现自动依赖注入的框架**。它的作用是管理对象的创建及其生命周期，并提供向类注入依赖项的具体实现，这样做是为了我们不必手动创建和管理对象。但**实际上更准确的描述应该是 DI 容器**，只不过因为 Spring 号称自己为 IoC 容器而造成了误解

![image-20210622163249708](img/image-20210622163249708.png)

![image-20210622163317016](img/image-20210622163317016.png)



## 惯例原则： 如何提升编程中的沟通效率



`惯例优于配置原则`



### CoC惯例原则

> 1. 惯例原则就是将一些在编程中公认的配置方式和约定信息作为内部缺省的默认规则来使用。
> 2. 主要解决了在编程中我们对共同隐性知识的学习问题，通过统一的默认规则，建立起了一道沟通的桥梁。



### 惯例原则的副作用

1. 丢失灵活性
2. 自定义惯例有风险
3. 参考变强制
4. 不同框架下的惯例之间并不能复用



### 如何正确使用惯例规则

1. 遵循大多数人使用的惯例
2. 搞清楚惯例的适用范围
3. 自定义惯例时需要在团队内反复不断确认
4. 要在惯例和灵活性之间做平衡
5. 不要强制他人使用惯例



## 分离原则： 如何将复杂问题拆分成小问题

> 关注点分离原则 是一个帮助我们将复杂问题拆分成小问题的好方法
>
> 关注点是能对程序代码产生影响的一组特定信息



### 为什么用关注点分离原则拆分复杂问题

1. 你破坏其他用户正在使用的现有功能的可能性会变小
2. 关注点分类能帮助你适应人类的短期记忆限制



### 两个视角下的关注点分离

> `现将复杂问题做合理的分解，在分别仔细研究上特定问题的侧面（关注点），最后解决得出的接口，再合成整体的解决思路`



#### 架构设计视角

> 侧重点： 整个系统内组件之间的边界划分
>
> **将层作为关注点来进行分离，通过解决每一个层的问题来实现整体问题的解决**。
>
> **架构设计视角下的关注点分离更重视组件之间的分离，并通过一定的通信策略来保证架构内各个组件间的相互引用**



#### 编码实现视角

> 侧重点 ： **某个具体类或方法间的边界划分**——————————————职责分离
>
> **虽然架构设计和编码实现中的关注点各有不同，但是对关注点进行分离后获得的效果却是一样的**。



### 如何实现关注点分离

> **好的架构必须使每个关注点相互分离，也就是说系统中的一部分发生了改变，并不会影响到其他部分**。这主要体现在这三个方面：
>
> 1. ①即使需要改变，也能够清晰地识别出哪些部分需要改变；
> 2. ②如果需要扩展架构，尽量做到影响最小化；
> 3. ③已经可以工作的部分还都将继续工作



#### 在架构设计上，做到策略和机制分离

- 机制
  - 各种软件要素之间的结构关系和运行方式。可以理解为实现某个功能所需要的基础操作和通用结构。在代码中相对稳定，表现形式有：通用算法、流程、数据结构等可以起到不可变作用的部分。
- 策略
  - 可以实现软件发布目标的编码方案集合。在代码中相对不稳定，表现形式有：业务逻辑、接口实现。

**策略和机制分离的本质就是进行标准化，也就是制定一套标准（提供机制），让使用者按照标准使用它（不同策略）**



#### 在编码实现上，做到使用和创建分离

**实体的实例化（创建）与实体间相互使用（使用）的分离**。





## 契约原则： 如何做好API接口设计



### 契约式设计原则（DbC）： API 设计的指导书

> 原理  :  **在软件设计时应该为软件组件定义一种精确和可验证的接口规范，这种规范要包括使用的预置条件、后置条件和不变条件，用来扩展普通抽象数据类型的定义**

1. API 必须保证输入是接收者期望的输入条件
2. API 必须要保证输出结果的正确性
3. API必须要保证处理过程的一致性



### 如何做好API接口设计

#### 让接口职责分离

#### APi命名很重要

#### 尽量少创造自定义错误码

#### 同一接口要做到幂等

> **什么是幂等？简单来说，就是当一个操作多次执行所产生的影响均与一次执行的影响相同，则它是幂等的。**

如何做到接口幂等：

1. 使用天然幂等条件： 比如 数据库 查询，删除
2. 使用唯一键值
3. 使用加锁策略。 比如 悲观锁，乐观锁，分布式锁
4. 使用Source + Token 验证机制
5. 使用有限状态机



# 拆解23种设计模式的实现原理



## 单例模式：如何有效进行程序初始化

![image-20210624165223190](img/image-20210624165223190.png)

为此我就结合我多年学习设计模式的经验，总结出了一个简单的学习框架，它可以帮助你更高效地学习设计模式。

    这个模式中隐藏（封装）了什么实现（变化）？
    
    这个模式中有什么共性规律（哪类变化）？
    
    这个模式中的对象职责是什么？
    
    这个模式中对象之间的关系是什么？
    
    这个模式常用在哪些场景中？
    
    这个模式基于常用场景的通用代码实现是什么？
    
    这个模式如何基于上下文环境来进行设计和使用？


### 单例模式分析

> 单例模式 ： 容许存在一个和仅存一个给定类的实例。它提供一种机制让任何实体都可以访问该实例

```java
public class Singleton {
		//用于存储单一实例的静态对象
    private static Singleton _instance; 
		//私有的空构造函数
    private Singleton(){
    };
		//通过判断静态对象是否被初始化来选择是否创建对象
    public static Singleton getInstance(){

        if (null == _instance){
            _instance = new Singleton();
        }
        return _instance;

    }
}

```

三个要点：

1. 一个单例类只能有一个实例
2. 单例类必须自行创建这个实例
3. 单例类必须保证全局其他对象都能唯一访问到它



单例模式的对象职责：

1. 保证一个类只有一个实例
2. 为该实例提供一个全局访问节点

**单例模式就类似于全局变量或全局函数的角色，可以使用它来代替全局变量**。



### 常见场景和解决方案

> 单例模式更多的是程序一开始进行初始化时使用的
>
> 常见的单例模式应用和使用的解决方案有：饿汉式初始化、懒汉式初始化、同步信号、双重锁定和使用 ThreadLocal。

```java
import java.util.HashMap;

import java.util.Map;

public class AppContext {

    private static final ThreadLocal<AppContext> local = new ThreadLocal<>();

    private Map<String,Object> data = new HashMap<>();

    public Map<String, Object> getData() {

        return getAppContext().data;

    }

    //批量存数据

    public void setData(Map<String, Object> data) {

        getAppContext().data.putAll(data);

    }

    //存数据

    public void set(String key, String value) {

        getAppContext().data.put(key,value);

    }

    //取数据

    public void get(String key) {

        getAppContext().data.get(key);

    }

    //初始化的实现方法

    private static AppContext init(){

        AppContext context = new AppContext();

        local.set(context);

        return context;

    }

    //做延迟初始化

    public static AppContext getAppContext(){

        AppContext context = local.get();

        if (null == context) {

            context = init();

        }

        return context;

    }

    //删除实例

    public static void remove() {

        local.remove();

    }

}

```

**而 ThreadLocal 则会为每一个线程提供一个独立的对象副本**，从而解决了多个线程对数据的访问冲突的问题。正因为每一个线程都拥有自己的对象副本，也就省去了线程之间的同步操作。

所以说，**现在绝大多数单例模式的实现基本上都是采用的 ThreadLocal 这一种实现方式**。



### 为什么使用单例模式

1. 系统某些资源有限

2. 需要表示为全局唯一的对象

   



## 建造者模式： 如何创建不同形式的复杂对象



> 第二个高频使用的创建型设计模式——Builder模式 ，， 称为 建造者模式 或生成器模式
>
> 就是先创建一个建造者，然后给建造者指定一个构建算法，建造者按照算法中的步骤分步完成对象的构建，最后获取最终对象

![image-20210625135011033](img/image-20210625135011033.png)

- **Product**：代表最终构建的对象，比如，汽车类。
- **Builder**：代表建造者的抽象基类（可以使用接口来代替）。它定义了构建 Product 的步骤，它的子类（或接口实现类）需要实现这些步骤。同时，它还需要包含一个用来返回最终对象的方法 getProduct()。
- **ConcreteBuilder**：代表 Builder 类的具体实现类。
- **Director**：代表需要建造最终对象的某种算法。这里通过使用构造函数 Construct(Builder builder) 来调用 Builder 的创建方法创建对象，等创建完成后，再通过 getProduct() 方法来获取最终的完整对象。

```java
public class Product {

    private int partA;

    private String partB;

    private int partC;

    public Product(int partA, String partB, int partC) {

        this.partA = partA;

        this.partB = partB;

        this.partC = partC;

    }

    @Override

    public String toString() {

        return "Product{" +

                "partA=" + partA +

                ", partB='" + partB + '\'' +

                ", partC=" + partC +

                '}';

    }

}

public interface Builder {

    void buildPartA(int partA);

    void buildPartB(String partB);

    void buildPartC(int partC);

    Product getResult();

}

public class ConcreteBuilder implements Builder {

    private int partA;

    private String partB;

    private int partC;

    @Override

    public void buildPartA(int partA) {

        this.partA = partA;

    }

    @Override

    public void buildPartB(String partB) {

        this.partB = partB;

    }

    @Override

    public void buildPartC(int partC) {

        this.partC = partC;

    }

    public Product getResult(){

        return new Product(partA,partB,partC);

    }

}

public class Director {

    public void construct(Builder builder) {

        builder.buildPartA(1);

        builder.buildPartB("test-test");

        builder.buildPartC(2);

    }

    

}

```

```java
    public static void main(String[] args) {

        Director director = new Director();

        Builder builder = new ConcreteBuilder();

        director.construct(builder);

        System.out.println(builder.getResult());

    }

```



### 常用场景分析

1. 需要生成的对象包含多个成员属性
2. 需要生成的对象的属性相互依赖，需要指定其生成顺序
3. 对象的创建过程独立于创建对象的类
4. 需要隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。



### 案例

#### 没有使用建造者模式

```java
public class MigrantWorkerOld {

    private String name;    //姓名

    private int age;        //年龄

    private String phone;   //电话

    private String gender;  //性别

    public MigrantWorkerOld(String name, int age, String phone, String gender) {

        this.name = name;

        this.age = age;

        this.phone = phone;

        this.gender = gender;

    }

    public MigrantWorkerOld(String name, int age, String phone) {

        this.name = name;

        this.age = age;

        this.phone = phone;

    }

    public MigrantWorkerOld(String name, int age) {

        this.name = name;

        this.age = age;

    }

    

}

```

#### 使用建造者模式的类

```java 
public class MigrantWorker {

    //所有属性

    private String name;   

    private int age;       

    private String phone;  

    private String gender; 

    public MigrantWorker() {

    }

    public static MigrantWorker builder() {

        return new MigrantWorker();

    }

    //将属性作为步骤

    public MigrantWorker name(String name) {

        this.name = name;

        return this;

    }

    //将属性作为步骤

    public MigrantWorker age(int age) {

        this.age = age;

        return this;

    }

    //将属性作为步骤

    public MigrantWorker phone(String phone) {

        this.phone = phone;

        return this;

    }

    //将属性作为步骤

    public MigrantWorker gender(String gender) {

        this.gender = gender;

        return this;

    }

    //执行创建操作

    public MigrantWorker build() {

        validateObject(this);

        return this;

    }

    private void validateObject(MigrantWorker migrantWorker) {

        //可以做基础预校验，或自定义校验

    }

    @Override

    public String toString() {

        return "MigrantWorker{" +

                "name='" + name + '\'' +

                ", age=" + age +

                ", phone='" + phone + '\'' +

                ", gender='" + gender + '\'' +

                '}';

    }

}

```

```java
public static void main(String[] args) {

    MigrantWorker migrantWorker1 = MigrantWorker.builder()

            .name("Spike")

            .age(27)

            .phone("1810000111")

            .gender("男")

            .build();

    System.out.println(migrantWorker1);

    MigrantWorker migrantWorker2 = MigrantWorker.builder()

            .name("Max")

            .age(7)

            .phone("1810000222")

            //没有性别

            .build();

    System.out.println(migrantWorker2);

    MigrantWorker migrantWorker3 = MigrantWorker.builder()

            .name("Mia")

            .age(17)

            //没有 电话

            .gender("女")

            .build();

    System.out.println(migrantWorker3);

    MigrantWorker migrantWorker4 = MigrantWorker.builder()

            .name("Mick")

            //没有 年龄

            //没有 电话

            //没有 性别

            .build();

    System.out.println(migrantWorker4);

}

```

### 为什么使用建造者模式

> 在实际的使用中，通常可以**直接使用 lombok 的 @Builder 注解实现类自身的建造者模式**，或者**使用案例中的将自身类作为建造者的方法**来实现。
>
> 所有JDK类库中的Appendable 接口都是实现了建造者模式的优秀范例

**第一，分阶段、分步骤的方法更适合多次运算结果类创建场景**

**第二，不需要关心特定类型的建造者的具体算法实现。**



### 收获什么，损失什么

1. 分离创建与使用
2. 满足开闭原则
3. 自由的组合对象的创建过程



1. 使用范围优先
2. 容易引起超大的类
3. 增加代码的行数



## 抽象工厂模式： 如何统一不同风格下的代码级别

> 工厂模式 一般被分为： 简单工厂、工厂方法和抽象工厂。
>
> `学习抽象工厂模式真正的重点和难点在于： 如何找到正确的抽象`



### 模式原理分析

抽象工厂模式的原始定义是：提供了一个用于创建相关或相关对象族的接口，而无须指定其具体类。

实际上，这句话是给使用者说的。因为从使用者的角度来看，他有时可能只关心某一个抽象的大类，就好比你去租车时，你对店员说，你想要租一辆小型轿车，但具体品牌和型号你并不在意。而站在创建者的角度看，他需要关注的是如何找到这个正确的抽象大类，就好比在上面的租车场景中，你需要从普通的汽车消费者变成汽车厂的厂长一样，你必须关注最后具体的型号该怎么落地。

所以说，**当我们在创建抽象工厂模式时，最终还是会涉及指定具体的实现类**。换句话说，定义只是说了抽象工厂模式应该要朝着分析共性规律的方向走，而具体操作时我们还得仔细分析具体实现类该怎么实现才行

![image-20210625145747700](img/image-20210625145747700.png)

`抽象产品的好坏才是直接决定了抽象工厂的具体工厂能否发挥最大作用的关键所在`

```java
public class Client {

    private Chair myChair;

    private Sofa mySofa;

    private Table myTable;

	//通过抽象工厂来生产家具

    public Client(AbsractFactory af){

        myChair = af.createChair();

        mySofa = af.createSofa();

        myTable = af.createTable();

    }

}

//抽象的家具工厂

public abstract class AbsractFactory {

    abstract Chair createChair();

    abstract Sofa createSofa();

    abstract Table createTable();

}

//中国的家具工厂

public class ChinaFactory extends AbsractFactory {

    @Override

    Chair createChair() {

        return new ChinaChair();

    }

    @Override

    Sofa createSofa() {

        return new ChinaSofa();

    }

    @Override

    Table createTable() {

        return new ChinaTable();

    }

}

//美国的家具工厂

public class USAFactory extends AbsractFactory{

    @Override

    Chair createChair() {

        return new USAChair();

    }

    @Override

    Sofa createSofa() {

        return new USASofa();

    }

    @Override

    Table createTable() {

        return new USATable();

    }

}

```

从上面代码实现中我们可以看出，抽象工厂模式向使用（客户）方隐藏了下列变化：

- 程序所支持的实例集合（具体工厂）的数目；
- 当前是使用的实例集合中的哪一个实例；
- 在任意给定时刻被实例化的具体类型；
- 实例集变化的依据。





对于**软件使用者**来说，他们其实更关心某一组产品的某些共性功能，至于这些功能具体的实现他们并不在意。反过来，对于**软件创建者**来说，他们要找到正确的共性功能，并尽可能隐藏具体的实现细节，始终围绕着提供符合共性功能的软件。比如，Spring 框架就是始终围绕着如何正确地管理（创建、使用、销毁）Java 对象生命周期这个共性功能。



### 使用场景分析



`简单来说，在软件开发中，抽象工厂模式的使用场景主要就是解决跨平台兼容性的问题`

总结来说，**在实际的代码实现中，抽象工厂模式体现为定义一个抽象工厂类，多个不同的具体工厂继承这个抽象工厂类后，再各自实现相同的抽象功能，进而实现代码上的多态性**

### 为什么要使用抽象工厂模式

1. 对于不同产品系列有比较多的共性特征时，可以使用抽象工厂模式，有助于提升组件的复用性。
2. 当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能有效的将代码统一到一个级别上。
3. 解决跨平台带来的兼容性问题。

### 收获什么？损失什么？

1. 符合开闭原则
2. 可以保证同一工厂生成的产品符合预期
3. 将使用和创建的代码进行解耦
4. 满足单一职责原则
5. 容易增加新的产品系列



1. 增加代码量
2. 增加学习成本
3. 变更产品的结构困难





## 工厂方法模式： 如何解决生成对象时的不确定性

> 工厂方法模式俗称工厂模式，
>
> 工厂方法模式因为只围绕着一类接口来进行对象的创建与使用，使用场景更简单和单一，在实际的项目中使用频率反而比抽象工厂模式更高



### 模式原理分析

> 原始定义： 定义一个创建对象的接口，但让实现这个接口的类来决定实例化那个类
>
> 目的： `封装对象创建的过程，提升创建对象方法的可复用性`

![image-20210706140511917](img/image-20210706140511917.png)

> 不同于抽象工厂模式，工厂模式侧重于`直接对具体产品的实现进行封装和调用，通过统一的接口定义来约束程度的对外行为`。换句话说，**用户通过使用核心工厂来获得具体实例对象，在通过对象的统一接口来使用对象功能**

```java
//抽象产品

public interface IProduct {

    void apply();

}

//核心工厂类

public class ProductFactory {

    public static IProduct getProduct(String name){

        if ("a".equals(name)) {

            return new Product_A_Impl();

        }

        return new Product_B_Impl();

    }

}

//具体产品实现A

public class Product_A_Impl implements IProduct{

    @Override

    public void apply() {

        System.out.println("use A product now");

    }

}

//具体产品实现B

public class Product_B_Impl implements IProduct{

    @Override

    public void apply() {

        System.out.println("use B product now");

    }

}

//client使用者

public static void main(String[] args) {

    IProduct iProduct = ProductFactory.getProduct("");

    iProduct.apply();

    IProduct iProducta = ProductFactory.getProduct("a");

    iProducta.apply();

}

```

> 总体来说： 工厂方法模式是围绕着特定的抽象产品（一般是接口）来封装对象的创建过程，客户端只需要通过工厂类来创建对象并使用特定接口的功能

![image-20210706154717416](img/image-20210706154717416.png)



myBatis 案例

```java
 public final class LogFactory {

    public static final String MARKER = "MYBATIS";

    private static Constructor<? extends Log> logConstructor;

    private LogFactory() {

    }

    public static Log getLog(Class<?> clazz) {

        return getLog(clazz.getName());

    }

    public static Log getLog(String logger) {

        try {

            return (Log)logConstructor.newInstance(logger);

        } catch (Throwable var2) {

            throw new LogException("Error creating logger for logger " + logger + ".  Cause: " + var2, var2);

        }

    }

    ...省略具体工厂实现类...

    private static void tryImplementation(Runnable runnable) {

        if (logConstructor == null) {

            try {

                runnable.run();

            } catch (Throwable var2) {

            }

        }

    }

    private static void setImplementation(Class<? extends Log> implClass) {

        try {

            Constructor<? extends Log> candidate = implClass.getConstructor(String.class);

            Log log = (Log)candidate.newInstance(LogFactory.class.getName());

            if (log.isDebugEnabled()) {

                log.debug("Logging initialized using '" + implClass + "' adapter.");

            }

            logConstructor = candidate;

        } catch (Throwable var3) {

            throw new LogException("Error setting Log implementation.  Cause: " + var3, var3);

        }

    }

    static {

        tryImplementation(LogFactory::useSlf4jLogging);

        tryImplementation(LogFactory::useCommonsLogging);

        tryImplementation(LogFactory::useLog4J2Logging);

        tryImplementation(LogFactory::useLog4JLogging);

        tryImplementation(LogFactory::useJdkLogging);

        tryImplementation(LogFactory::useNoLogging);

    }

}

public interface Log {

    boolean isDebugEnabled();

    boolean isTraceEnabled();

    void error(String var1, Throwable var2);

    void error(String var1);

    void debug(String var1);

    void trace(String var1);

    void warn(String var1);

}

```

### 为什么要用工厂方法模式

1. 为了把对象的创建和使用过程分开，降低代码耦合性
2. 减少重复代码
3. 统一管理创建对象的不同实现逻辑 

### 收益与损失

#### 优点

1. 能根据用户的需求定制化地创建对象
2. 隐藏了具体使用那种产品来创建对象
3. 实现同一抽象父类的多态性，满足LSP
4. 满足开闭原则

#### 缺点

1. 抽象接口新增方法时，会增加开发成本
2. 具体工厂实现逻辑不统一，增加代码理解难度



## 原型模式： 什么场景下需要用到对象拷贝

> 原型模式最初的思维模型： **拥有一张可以实例化成许多副本的原图，如果用户更改了主工程图，则所有实例也会更改。**

### 模式原理分析

![image-20210706164626827](img/image-20210706164626827.png)

```java
public interface PrototypeInterface extends Cloneable {

    PrototypeInterface clone() throws CloneNotSupportedException;

}

public class ProtypeA implements PrototypeInterface {

    @Override

    public ProtypeA clone() throws CloneNotSupportedException {

        System.out.println("Cloning new object: A");

        return (ProtypeA) super.clone();

    }

}

public class ProtypeB implements PrototypeInterface {

    @Override

    public ProtypeB clone() throws CloneNotSupportedException {

        System.out.println("Cloning new object: B");

        return (ProtypeB) super.clone();

    }

}

//ProtypeA以自己为原型通过拷贝创建一个新的对象newInstanceA

public static void main(String[] args) throws CloneNotSupportedException {

    ProtypeA source = new ProtypeA();

    System.out.println(source);



    ProtypeA newInstanceA = source.clone();

    System.out.println(newInstanceA);

}

```



> 原型模式从建立原型到拷贝原型生成新实例，都是对用户透明的，一旦中间任何一个小细节出现问题，你可能获取的就是一个错误的对象。



### 使用场景分析

1. 资源优化场景
2. 复杂的依赖场景
3. 性能和安全要求的场景
4. 同一个对象可能被多个修改者使用的场景
5. 需要保存原始对象状态的场景
6. 结合工厂模式来使用

> 浅拷贝与深拷贝。当我们在做对象拷贝时，需要在浅拷贝和深拷贝之间做取舍。如果类仅包含原始字段和不可变字段，可以使用浅拷贝；如果类还包含有可变字段的引用（比如，对象中包含对象），那么我们就应该使用深拷贝。



### 为什么要使用原型模式

1. 减少每次创建对象的资源消耗
2. 减低对象创建的时间消耗
3. 快速复制对象运行时状态
4. 能保存原始对象的副本



### 收益什么？损失什么？

#### 优点

1. 原型并不基于继承，因此没有继承的缺点
2. 复制大对象时，性能更优。
3. 可以快速扩展运行时对象的属性和方法

#### 缺点：

1. 虽然不基于继承，但原型需要一个被初始化过的正确对象
2. 复制大对象时，可能会出现内存OOM错误
3. 动态扩展对象功能时可能会掩盖新的风险



## 适配器模式： 如何处理不同API接口的兼容性

> 结构型模式： 适配器模式、桥接模式、组合模式、装饰模式、门面模式、享元模式和代理模式



### 模式原理分析

> 将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的类一起协同工作

![image-20210706172231458](img/image-20210706172231458.png)

```java
public abstract class TargetAbstraction {

    public abstract String filter(String str);

}

public class TargetAbstractionImpl extends TargetAbstraction {

    @Override

    public String filter(String str) {

        return str.replaceAll("a","A");

    }

}

public class Adapter extends TargetAbstraction {

    private OtherClass otherClass;

    public Adapter() {

        otherClass = new OtherClass();

    }

    @Override

    public String filter(String str) {

        otherClass.preCheck(str);

        return otherClass.replace(str);

    }

}

public class OtherClass {

    public OtherClass() {

    }

    public String replace(String str){

            return str.replaceAll("<","[");

    }

    public void preCheck(String str){

    }

}

```

> 核心原理就是在**原有的接口或类的外层封装一个新的适配器层，以实现扩展对象结构的效果，并且这种扩展可以无限扩展下去**

### 使用场景分析

1. 原有接口无法修改时
2. 原有接口功能太老旧
3. 统一多个类的接口设计时
4. 需要过渡升级旧接口
5. 需要依赖外部系统
6. 适配不同数据格式时
7. 不同接口协议转换时

> 使用场景两大类：
>
> 1. 原有接口功能不满足现有要求，需要在兼容老接口的同时做适当的扩展
> 2. 有相似性的多个不同接口之间做功能的统一



### 为什么 要使用适配器模式

1. 原有接口无法修改但又必须快速兼容部分新功能
2. 需要使用外部组件组合成新组件来 提供功能，而又不想重复开发部分功能
3. 不同数据格式、不同协议需要转换



### 收益什么？损失什么？

#### 优点

1. 将目标类和具体适配类解耦
2. 增加了类的透明性
3. 满足里氏替换原则
4. 符合开闭原则
5. 统一多个类或接口

#### 缺点

1. 一次只能适配一个抽象类或接口
2. 过度嵌套会导致接口臃肿
3. **目标接口依赖太多适配接口，修改目标接口会导致所有适配接口都需要定制修改**



## 桥接模式： 如何实现抽象协议与不同实现的绑定



### 模式原理分析

> 定义： 将抽象部分与它实现部分分离，使他们都可以独立地变化

![image-20210707085818641](img/image-20210707085818641.png)

**抽象的分离间接完成了具体类与具体类之间的解耦，它们之间使用抽象来进行组合或聚合，而不再使用继承**。

```java
public abstract class AbstractEntity {

    //行为对象

    protected AbstractBehavior myBehavior;

    //实体与行为的关联

    public AbstractEntity(AbstractBehavior aBehavior) {

        myBehavior = aBehavior;

    }

    //子类需要实现的方法

    public abstract void request();

}

public class DetailEntityA extends AbstractEntity {

    public DetailEntityA(AbstractBehavior aBehavior) {

        super(aBehavior);

    }

    @Override

    public void request() {

        super.myBehavior.operation1();

    }

}

public class DetailEntityB extends AbstractEntity {

    public DetailEntityB(AbstractBehavior aBehavior) {

        super(aBehavior);

    }

    @Override

    public void request() {

        super.myBehavior.operation2();

    }

}

public abstract class AbstractBehavior {

    public abstract void operation1();

    public abstract void operation2();

}

public class DetailBehaviorA extends AbstractBehavior{

    @Override

    public void operation1() {

        System.out.println("op-1 from DetailBehaviorA");

    }

    @Override

    public void operation2() {

        System.out.println("op-2 from DetailBehaviorA");

    }

}

public class DetailBehaviorB extends AbstractBehavior {

    @Override

    public void operation1() {

        System.out.println("op-1 from DetailBehaviorB");

    }

    @Override

    public void operation2() {

        System.out.println("op-2 from DetailBehaviorB");

    }

}

```

桥接模式封装变化的本质上是对事物进行分类（实体），并对实体中的功能性（行为）再划分的一种解决方案。比如，电子产品可以被分为手机、电脑等，其中手机隐藏了手机一类相关的变化；同样，手机和电脑都具备使用 App 软件的功能，它们各自隐藏了如何使用 App 的具体方式。

所以说，**桥接模式的本质是通过对一个对象进行实体与行为的分离，来将需要使用多层继承的场景转换为使用组合或聚合的方式，进而解耦对象间的强耦合关系，达到对象与对象之间的动态绑定的效果，提升代码结构的扩展性**



### 为什么要使用桥接模式

1. 为了灵活扩展代码结构
2. 为了更好的解决跨平台兼容性问题
3. 为了运行时组合不同的组件

### 收益什么？ 损失什么？

#### 优点

1. 分离实体与行为，可以提升各自维度的演化效率
2. 符合开闭原则，提升代码复用性
3. 用组合关系替代了多重继承，提升了代码结构的演化灵活性
4. 符合表达原则，提升代码的可理解性

#### 缺点

1. 增加了维护成本
2. 导致性能下降
3. 增加设计难度



## 组合模式： 如何用树形结构处理对象之间的复杂关系



### 模式原理分析

> 定义： 将对象组合成树形结构以表示整个部分的层次结构
>
> 1. 用树形结构来分层
> 2. 通过统一对待来简化操作

![image-20210707092345746](img/image-20210707092345746.png)

除了上述 的树形结构，还有 环形结构 和双向结构

![image-20210707092641925](img/image-20210707092641925.png)

```java
//抽象组件

public abstract class Component{

     public abstract void operation();

}

//叶子节点

public class Leaf extends Component{

    @Override

    public void operation() {

        //叶子节点的操作放这里

    }

}



//组合节点

public class Node extends Component {

    private List<Component> myChildren;  //存放子节点列表

    @Override

    public void operation() {

        for (Component component: myChildren) {

            component.operation();

        }

    }

}

```



### 使用场景分析

1. 处理一个树形结构，比如 公司人员组织架构，订单信息等
2. 跨越多个层次结构聚合数据，比如： 统计文件夹下文件总数
3. 统一处理一个结构中的多个对象，比如： 遍历文件夹下所有XML类型文件内容

### 为什么要使用组合模式

**第一，希望一组对象按照某种层级结构进行管理**，比如，管理文件夹和文件，管理订单下的商品等。树形结构天然有一种层次的划分特性，能够让我们自然地理解多个对象间的结构。

**第二，需要按照统一的行为来处理复杂结构中的对象**，比如，创建文件，删除文件，移动文件等。在使用文件时，我们其实并不关心文件夹和文件是如何被组织和存储的，只要我们能够正确操作文件即可，这时组合模式就能够很好地帮助我们组织复杂的结构，同时按照定义的统一行为进行操作。

**第三，能够快速扩展对象组合。** 比如，订单下的手机商品节点可以自由挂接不同分类的手机（品牌类的，如华为、苹果），并且还可以按照商品的特性（如，价格、图片、商家、功能等）再自由地挂接新的节点组合，而查找时可以从手机开始查找，不断增加节点类型，直到找到合适的手机商品



### 收获与损失

#### 优点

- **清晰定义分层结构**。组合模式在实现树形结构时，能够非常清楚地定义层次，并且能让使用者忽略层次的差异，以方便对整个层次结构进行控制。
- **简化了使用者使用复杂结构数据的代码**。由于组合模式中的对象只有组合节点和叶子节点两种类型，而节点的使用操作是一样的，比如，查找子节点，查找父节点等，那么对于使用者来说，就能使用一致的行为，而不用不关心当前处理的是单个对象还是整个结构，间接简化了使用者的代码。
- **快速新增节点，提升组合灵活性。** 在组合模式中，新增节点会很方便，而无须对现有代码进行任何修改，符合“开闭原则”；同时还能够在局部节点上按照相关性再进行自由的组合，大大提升了对象结构的灵活性。

#### 缺点

- **难以限制节点类型。** 比如，在上面的订单例子中，订单树中除了组合商品类的节点外，实际上只要不约束，就可以组合任意类型的节点，因为它们都来自同一个根节点，都属于节点类型，只不过节点里包含的信息各不相同罢了，所以，在使用组合模式时，通常需要在设计时从逻辑层面上进行一定的约束。
- **需要增加很多运行时的检查，增加了代码复杂度。** 一旦对象类型不能做限制后，就必须通过运行时来进行类型检查，而这个实现过程比较复杂，会增加很多额外的代码耦合性，同时还会增加代码的理解难度。
- **错误的遍历算法可能会影响系统性能。** 组合模式实现树形结构虽然好用，但是一旦使用了错误的遍历算法，就会在数据量剧增的情况下拖慢系统速度，比如，当使用简单多层 for  循环嵌套来查找全量的数据时，算法的时间复杂度可能是 m 次方  O(n^m)，会造成外部服务阻塞等待，这样很可能会直接导致其他服务因为长时间等待而出现超时错误。因此，使用组合模式时一定要谨慎选择遍历算法。



## 装饰模式： 如何在基础组件上扩展新功能

> 适配器模式侧重于转换，而装饰模式侧重于动态扩展；桥接模式侧重于横向宽度的扩展，而装饰模式侧重于纵向深度的扩展



### 模式原理分析

> 定义： 容许动态地向一个现有的对象加新的功能，同时又不改变其结构，相当于对现有的对象进行一个包装

![image-20210707093624673](img/image-20210707093624673.png)

```java
//组件

public interface Component {

    void excute();

} 

//具体组件

public class BaseComponent implements Component {

    @Override

    public void excute() {

        //do something

    }

}

//装饰器

public class BaseDecorator implements Component {

    private Component wrapper;

    public BaseDecorator(Component wrapper) {

        this.wrapper = wrapper;

    }

    @Override

    public void excute() {

        wrapper.excute();

    }

}

//具体装饰器A

public class DecoratorA extends  BaseDecorator {

    public DecoratorA(Component wrapper) {

        super(wrapper);

    }

    @Override

    public void excute() {

        super.excute();

    }

}

//具体装饰器B

public class DecoratorB extends  BaseDecorator {

    public DecoratorB(Component wrapper) {

        super(wrapper);

    }

    @Override

    public void excute() {

        super.excute();

    }

}

```

**装饰模式本质上就是给已有不可修改的类附加新的功能，同时还能很方便地撤销**。



### 使用场景分析

- **快速动态扩展和撤销一个类的功能场景。** 比如，有的场景下对 API 接口的安全性要求较高，那么就可以使用装饰模式对传输的字符串数据进行压缩或加密。如果安全性要求不高，则可以不使用。
- **可以通过顺序组合包装的方式来附加扩张功能的场景。** 比如，加解密的装饰器外层可以包装压缩解压缩的装饰器，而压缩解压缩装饰器外层又可以包装特殊字符的筛选过滤的装饰器等。
- **不支持继承扩展类的场景。** 比如，使用 final 关键字的类，或者系统中存在大量通过继承产生的子类。



### 为什么时候装饰模式

**第一个，为了快速动态扩展类功能，降低开发的时间成本。** 比如，一个类 A，有子类 A01、A02，然后 A01 又有子类  A001，以此类推，A0001、A00001……这样的设计会带来一个严重的问题，那就是：当需要扩展 A01 时，所有 A01  的子类和父类都会受到影响。但是，如果这时我们使用装饰器 B01、B02、C01、C02，那么扩展 A01 就会变为  A01B01C01、A01B02C02 这样的组合。这样就能快速地扩展类功能，同时还可以按需来任意组合，极大地节省了开发时间。

**第二个，希望通过继承的方式扩展老旧功能。** 比如，前面我们说到，当类标识有 final  关键字时，要想复用这个类就只能通过重新复制代码的方式，不过通常这样的类又处于需要对外提供功能的状态，不能轻易修改，而梳理上下文逻辑又费时费力，那么采用装饰模式就是一个很好的选择。因为装饰器是在外层进行扩展，即使功能不合适，也能及时地撤销而不影响原有的功能。所以说，在一些维护系统的升级或重构场景中，使用装饰模式来重构代码，在短期内都能达到快速解耦的效果。



### 收益和损失

#### 优点

- **快速扩展对象的功能。** 对于一些独立且无法修改的类来说，当需要在短期内扩展功能时，采用装饰模式能快速有效地扩展功能，同时也不会影响原有的功能。
- **可以动态增删对象实例的功能。** 比如，在上面文件读写器的例子中，我们可以在创建对象的时候再决定是一起使用压缩装饰器和加密装饰器，还是分开使用，或者只是用基本的读写功能。
- **可以在统一行为上组合几种行为。** 装饰模式是对某一个接口行为进行的组合扩展，通过包装的方式不断扩展代码的行为，从而实现了更多行为的组合。
- **满足单一职责原则。** 每一个具体装饰器类只实现一个组件的具体行为，即便附加了新的功能也是围绕着组件的职责而做扩展，保证了职责的单一性。

#### 缺点

- **在调用链中删除某个装饰器时需要修改代码。** 装饰模式的最大弊端在于，当在某个组件上附加了太多装饰器后，想要删除其中的某个装饰器时，就需要修改前后的装饰器的引用位置，这样容易导致上下文中代码都需要修改的情况，大大增加了出错的可能性。
- **容易导致产生很多装饰对象，增加代码理解难度。** 由于使用了组合方式，并且在调用时使用了链式结构，这样间接增加了很多装饰器对象，而一旦不了解装饰模式的特性，就很容易误解为多个对象的参数调用，增加了代码的理解难度。
- **增加问题定位和后期代码维护成本。** 虽然装饰模式使用的组合方式比继承更加灵活，但同时也会增加代码的复杂性，在维护代码时会增加问题定位难度，同时调试时也需要逐级排查，比较烦琐，增加了后期代码维护成本。



## 门面模式： 如何实现API网关的高可用性



### 模式原理分析

> 定义： 为子系统的一组接口提供统一的接口。

![image-20210707095048887](img/image-20210707095048887.png)

**本质就是简化外部系统使用内部多个子系统的使用方式**



### 使用场景分析

- **简化复杂系统。** 比如，当我们开发了一整套的电商系统后（包括订单、商品、支付、会员等系统），我们不能让用户依次使用这些系统后才能完成商品的购买，而是需要一个门户网站或手机 App 这样简化过的门面系统来提供在线的购物功能。
- **减少客户端处理的系统数量。**  比如，在 Web 应用中，系统与系统之间的调用可能需要处理 Database 数据库、Model 业务对象等，其中使用 Database  对象就需要处理打开数据库、关闭连接等操作，然后转换为 Model 业务对象，实在是太麻烦了。如果能够创建一个数据库使用的门面（其实就是常说的  DAO 层），那么实现以上过程将变得容易很多。
- **让一个系统（或对象）为多个系统（或对象）工作。** 比如，线程池 ThreadPool 就是一个门面模式，它为系统提供了统一的线程对象的创建、销毁、使用等。
- **联合更多的系统来扩展原有系统。** 当我们的电商系统中需要一些新功能时，比如，人脸识别，我们可以不需要自行研发，而是购买别家公司的系统来提供服务，这时通过门面系统就能方便快速地进行扩展。
- **作为一个简洁的中间层。**  门面模式还可以用来隐藏或者封装系统中的分层结构，同时作为一个简化的中间层来使用。比如，在秒杀、库存、钱包等场景中，我们需要共享有状态的数据时（如商品库存、账户里的钱），在不改变原有系统的前提下，通过一个中间的共享层（如将秒杀活动的商品库存总数统一放在 Redis 里），就能统一进行各种服务（如，秒杀详情页、商品详情页、购物车等）的调用。



### 为什么使用门面模式

1. 为了解决遗留系统重构的问题
2. 为了解决分层架构中的扩展问题



### 收益什么？ 损失什么？

#### 优点

**对使用者屏蔽子系统的细节，因而减少了使用者处理的对象数目，让整个系统使用起来更加方便**。比如，API 网关对外只有一个调用点，而后端服务可以用成百上千的服务系统连接网关。

**实现了子系统与使用者之间的松散耦合关系**。比如，活动时用户只需要点击抢购按钮就能实现一键下单并送货，用户不用知道商品系统是如何扣减商品的，也不用知道物流系统如何调度送货的。

**有助于建立层次结构系统，并简化层与层之间的依赖关系**。比如，视图层要访问存储层数据时，如果直接使用数据访问接口会造成依赖混乱，而按照某一个分类的服务建立一个门面服务层，比如，动态路由读写数据门面系统、数据埋点采集门面系统等，能够提供更简化统一的操作。

**能够消除复杂的循环依赖**。比如，为多个外部系统提供统一的 SDK 应用包，统一定义不同的接口方法，指定对应的子系统进行使用。

**有利于系统在不同平台之间的移植和重构**。 比如，系统早期通过 C# 实现，但现在团队期望通过 Java 进行重构，这时门面系统就可以充当中间的协议统一者，提供 HTTP 协议接口，然后逐渐迁移代码功能，使用过渡与升级同时并存的方式，完成系统的切换与升级



#### 缺点

1. 降低了可靠性
2. 容易导致子系统越来越复杂





## 享元模式：如何通过共享对象减少内存加载消耗



### 模式原理分析

> 原始定义： 摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，从而让我们能在有限的内存容量中载入更多的对象
>
> 要解决的核心问题就是**节约内存空间**，使用办法**是找出相似对象之间的共有特征，然后复用这些特征**

![image-20210707103844598](img/image-20210707103844598.png)

![image-20210707103909902](img/image-20210707103909902.png)

```java
//享元类

public interface Flyweight {

    void operation(int state);

}

//享元工厂类

public class FlyweighFactory {

    // 定义一个池容器

    public Map<String,Flyweight> pool = new HashMap<>();

    public FlyweighFactory() {

        pool.put("A", new ConcreteFlyweight("A"));//将对应的内部状态添加进去

        pool.put("B", new ConcreteFlyweight("B"));

        pool.put("C", new ConcreteFlyweight("C"));

    }

    //根据内部状态来查找值

    public Flyweight getFlyweight(String key) {

        if (pool.containsKey(key)) {

            System.out.println("===享元池中有，直接复用，key："+key);

            return pool.get(key);

        } else {

            System.out.println("===享元池中没有，重新创建并复用，key："+key);

            Flyweight flyweightNew = new ConcreteFlyweight(key);

            pool.put(key,flyweightNew);

            return flyweightNew;

        }

    }

}

//共享的具体享元类

public class ConcreteFlyweight implements Flyweight {

    private String uniqueKey;

    public ConcreteFlyweight(String key) {

        this.uniqueKey = key;

    }

    @Override

    public void operation(int state) {

        System.out.printf("=== 享元内部状态：%s,外部状态：%s%n",uniqueKey,state);

    }

}



//非共享的具体享元类

public class UnsharedConcreteFlyweight implements Flyweight {

    private String uniqueKey;

    public UnsharedConcreteFlyweight(String key) {

        this.uniqueKey = key;

    }

    @Override

    public void operation(int state) {

        System.out.println("=== 使用不共享的对象，内部状态："+uniqueKey+"，外部状态："+state);

    }

}



输出结果：

====享元池中有，直接复用，key：A

=== 享元内部状态：A,外部状态：9

====享元池中有，直接复用，key：B

=== 享元内部状态：B,外部状态：8

====享元池中没有，重新创建并复用，key：D

=== 享元内部状态：D,外部状态：7

====创建不共享的对象，key：uX

=== 使用不共享的对象，内部状态：uX，外部状态：6

```



它们的本质区别在于：**享元模式要解决的问题是节约内存的空间大小，而缓存模式本质上是为了节省时间**。

所以说，**享元模式本质上是通过创建更多的可复用对象的共有特征来尽可能地减少创建重复对象的内存消耗**。



### 使用场景分析

享元模式本质上在使用时就是找到不可变的特征，并缓存起来，当类似对象使用时从缓存中读取，以达到节省内存空间的目的



### 为什么时候享元模式

**第一个，减少内存消耗，节省服务器成本。**  比如，当大量商家的商品图片、固定文字（如商品介绍、商品属性）在不同的网页进行展示时，通常不需要重复创建对象，而是可以使用同一个对象，以避免重复存储而浪费内存空间。由于通过享元模式构建的对象是共享的，所以当程序在运行时不仅不用重复创建，还能减少程序与操作系统的 IO 交互次数，大大提升了读写性能。

**第二个，聚合同一类的不可变对象，提高对象复用性。** 比如，Java 中的 Number 对象族类（Integer、Long、Double 等）都是使用了享元模式例子，通过缓存不同范围数值来重复使用相同的数值。



### 收益什么，损失什么

#### 优点

- **可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。**
- **通过封装内存特有的运行状态，达到共享对象之间高效复用的目的。**

#### 缺点

- **以时间换空间，间接增加了系统的实现复杂度**。比如，需要分离出内部状态和外部状态，其中，外部状态这个定义比较模糊，也很难统一，而内部状态除了一些常用的常量容易被找到以外，那些更通用的组件对象在不同的业务系统中其实是不容易被找到的，因为不同的人对相似对象的理解并不一致，这就需要对程序员的代码设计实现思维有一定的要求。
- **运行时间更长，对于一些需要快速响应的系统并不合适**。享元模式的目的是节省空间，而没有说需要提供更短的时间，这适合数据类项目的使用，而不适合一些有高并发要求的系统。



## 代理模式： 如何控制和管理对象的访问

> 定义： 让你能够提供对象的替代品或其他占位符。
>
> **代理模式是作为对象之间的一种中间结构来使用的，通过构建一个代理对象来对原始的功能进行委托处理，其中有一个很重要的功能就是控制对象的访问**。

![image-20210707105840248](img/image-20210707105840248.png)

```java
public interface RealObject {

    void doSomething();

}

public class RealObjectImpl implements RealObject {

    @Override

    public void doSomething() {

        System.out.println("=== 真实对象输出打印");

    }

}

public class Proxy extends RealObjectImpl {

    @Override

    public void doSomething() {

        //这里做一些代理操作或额外的操作

        System.out.println("== 通过代理类来执行真实对象");

        super.doSomething();

    }

}

//单元测试

public class Demo {

    public static void main(String[] args) {

        RealObject realObjectProxy = new Proxy();

        realObjectProxy.doSomething();

    }

}

输出：

== 通过代理类来执行真实对象

=== 真实对象输出打印

```

**作为一个外包装的中间层，享有控制住访问对象的权利，同时也能扩展一些功能**。

### 为什么使用代理模式

1. 客户端有时无法直接操作某些对象，，，RPC 就代理模式
2. 客户端执行某些耗时操作容易造成服务端阻塞
3. 服务端需要控制客户端的访问权限



### 使用场景分析

**第一类，虚拟代理，适用于延迟初始化，用小对象表示大对象的场景**

**第二类，保护代理，适用于服务端对客户端的访问控制场景**。

**第三类，远程代理，适用于需要本地执行远程服务代码的场景。**

**第四类，日志记录代理，适用于需要保存请求对象历史记录的场景**，

**第五类，缓存代理，适用于缓存客户请求结果并对缓存生命周期进行管理的场景**



### 优劣点

#### 优点

- 作为接口的特定中间层，能够降低对象间的直接耦合。代理对象很好地解耦了客户端与服务端之间的调用关系，即使客户端在使用服务端对象还未准备好或不存在时，代理也可以正常工作。
- 虚拟代理通过延迟加载以及使用小对象代表大对象的方式，帮助减少系统资源的损耗，提升系统运行速度。
- 保护代理可以控制客户端对服务端的访问权限。
- 远程代理帮助客户端快速访问分布式机器上的对象，分布式服务器通常可以提供集群负载均衡、故障容错和高性能的计算能力。
- 日志记录代理能记录每次操作的信息，对于用户使用轨迹跟踪、数据统计、定位问题等都有重要作用。
- 缓存代理能够提供各式各样的缓存结果，对于需要高频读取重复数据的系统来说，能极大地提升系统性能。

#### 缺点

- 因为在客户端和服务端之间增加了代理对象，所以也增加了系统的复杂度。
- 实现了代理模式的服务，如果处理请求的时间过长，就容易造成多个服务调用阻塞而影响整体系统的处理速度。
- 对于一些偏操作系统或标准协议等底层的代理服务而言，代码实现可能很复杂。





## 访问者模式：如何实现对象级别的矩阵结构

> 行为型设计模式 ： 主要关注点是对象内部算法及对象之间的职责和分配

![image-20210707112949635](img/image-20210707112949635.png)

### 模式原理分析

> 定义 ：  容许在运行时将一个或多个操作应用于一组对象，将操作与对象结构分离
>
> 关键点：一个是**运行时使用一组对象的一个或多个操作**，比如，对不同类型的文件（.pdf、.xml、.properties）进行扫描；另一个是**分离对象的操作和对象本身的结构**
>
> 换句话说： **访问者模式是以行为（某一个操作）作为扩展对象功能的出发点，再不改变已有类的功能的前提下进行批量扩展**

![image-20210707140823266](img/image-20210707140823266.png)

```java
public interface Visitor {

    void visitA(ElementA elementA);

    void visitB(ElementB elementB);

    //...

    //void visitN(ElementN elementN);

}

public class VisitorBehavior implements Visitor {

    @Override

    public void visitA(ElementA elementA) {

        int x = elementA.getAState();

        x++;

        System.out.println("=== 当前A的state为："+x);

        elementA.setAState(x);

    }

    @Override

    public void visitB(ElementB elementB) {

        double x = elementB.getBState();

        x++;

        System.out.println("=== 当前B的state为："+x);

        elementB.setBState(x);

    }

}

public interface Element {

    void accept(Visitor v);

}

public class ElementA implements Element {

    private int stateForA = 0;

    public void accept(Visitor v) {

        System.out.println("=== 开始访问元素 A......");

        v.visitA(this);

    }

    public int getAState(){

        return stateForA;

    }

    public void setAState(int value){

        stateForA = value;

    }

}

// 单元测试

public class Demo {

    public static void main(String[] args) {

        List<Element> elementList = new ArrayList<>();

        ElementA elementA = new ElementA();

        elementA.setAState(11);

        ElementB elementB = new ElementB();

        elementA.setAState(12);

        elementList.add(elementA);

        elementList.add(elementB);

        for (Element element :elementList) {

            element.accept(new VisitorBehavior());

        }

    }

}

//输出结果

```



### 为什么使用访问者模式

1. 解决编程部分语言不支持动态双分派的能力

   > 比如，Java  是静态多分派、动态单分派的语言。什么叫双分派？所谓双分派技术就是在选择一个方法的时候，不仅要根据消息接收者的运行时来判断，还要根据参数的运行时判断。与之对应的就是单分派，在选择一个方法的时候，只根据消息接收者的运行时来判断。实际上，很多时候我们都无法提前预测所有程序运行的行为，需要在运行时动态传入参数来改变程序的行为，对于 Java 这类语言就需要通过设计模式来弥补这部分功能。

2. 需要动态绑定不同的对象和对象操作

3. 通过行为与对象结构的分离，实现对象的职责分离，提高代码复用性



### 使用场景分析

1. 当对象的数据结构相对稳定，而操作却经常变化的时候
2. 需要将数据结构与不常用的操作进行分离的时候
3. 需要在运行时动态决定使用那些对象和方法的时候



### 优劣

#### 优点

1. 简化客户端操作
2. 增加新的访问操作和访问者会非常便捷
3. 满足开闭原则
4. 满足单一职责原则



#### 缺点

1. 增加新的数据结构困难
2. 具体元素在变更时需要修改代码，容易引入问题





## 模板方法模式：如何实现同一模板框架的算法扩展



### 模式原理分析

> 原始定义： 在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。
>
> 我们能看出模板方法模式的定位很清楚，就是**为了解决算法框架这类特定的问题**，同时明确表示**需要使用继承的结构**

![image-20210707153206189](img/image-20210707153206189.png)

```java
public abstract class AbstractClassTemplate {

    void step1(String key){

        //dosomthing

        System.out.println("=== 在模板类里 执行步骤 1");

        if (step2(key)) {

            step3();

        } else {

            step4();

        }

        step5();

    }

    boolean step2(String key){

        System.out.println("=== 在模板类里 执行步骤 2");

        if ("x".equals(key)) {

            return true;

        }

        return false;

    }

    abstract void step3();

    abstract void step4();

    void step5() {

        System.out.println("=== 在模板类里 执行步骤 5");

    }

    void run(String key){

        step1(key);

    }

}

public class ConcreteClassA extends AbstractClassTemplate {

    @Override

    void step3() {

        System.out.println("===在子类 A 中 执行：步骤3");

    }

    @Override

    void step4() {

        System.out.println("===在子类 A 中 执行：步骤4");

    }

}

public class ConcreteClassB extends AbstractClassTemplate {

    @Override

    void step3() {

        System.out.println("===在子类 B 中 执行：步骤3");

    }

    @Override

    void step4() {

        System.out.println("===在子类 B 中 执行：步骤4");

    }

}

public class Demo {

    public static void main(String[] args) {

        AbstractClassTemplate concreteClassA = new ConcreteClassA();

        concreteClassA.run("");

        System.out.println("===========");

        AbstractClassTemplate concreteClassB = new ConcreteClassB();

        concreteClassB.run("x");

    }

}

//输出结果：

=== 在模板类里 执行步骤 1

=== 在模板类里 执行步骤 2

===在子类 A 中 执行：步骤4

=== 在模板类里 执行步骤 5

===========

=== 在模板类里 执行步骤 1

=== 在模板类里 执行步骤 2

===在子类 B 中 执行：步骤3

=== 在模板类里 执行步骤 5

```

总之，模板方法模式的实现原理很简单，就是**一个父类下面的子类通过继承父类而使用通用的逻辑，同时根据各自需要优化其中某些步骤**



### 为什么使用模板方法模式

1. 期望在一个通用的算法或流程框架下进行自定义开发
2. 避免同样的代码逻辑进行重复编码



### 使用场景分析

- 多个类有相同的方法并且逻辑可以共用时；
- 将通用的算法或固定流程设计为模板，在每一个具体的子类中再继续优化算法步骤或流程步骤时；
- 重构超长代码时，发现某一个经常使用的公有方法。

```java
public abstract class DeployFlow {

    //使用final关键字来约束步骤不能轻易修改

    public final void buildFlow() {

        pullCodeFromGitlab(); //从GitLab上拉取代码

        compileAndPackage();  //编译打包

        copyToTestServer();   //部署测试环境

        testing();            //测试

        copyToRemoteServer(); //上传包到线上环境

        startApp();           //启动程序

    }

    public abstract void pullCodeFromGitlab();

    public abstract void compileAndPackage();

    public abstract void copyToTestServer();

    public abstract void testing();

    private void copyToRemoteServer() {

        System.out.println("统一自动上传 启动App包到对应线上服务器");

    }

    private void startApp() {

        System.out.println("统一自动 启动线上App");

    }

}

```

我们分别实现两个子类：①实现本地的打包编译和上传；②实现全自动化的持续集成式的发布。

```java
public class LocalDeployFlow extends DeployFlow{

    @Override

    public void pullCodeFromGitlab() {

        System.out.println("手动将代码拉取到本地电脑......");

    }

    @Override

    public void compileAndPackage() {

        System.out.println("在本地电脑上手动执行编译打包......");

    }

    @Override

    public void copyToTestServer() {

        System.out.println("手动通过 SSH 上传包到本地的测试服务......");

    }

    @Override

    public void testing() {

        System.out.println("执行手工测试......");

    }

}

public class CicdDeployFlow extends DeployFlow{

    @Override

    public void pullCodeFromGitlab() {

        System.out.println("持续集成服务器将代码拉取到节点服务器上......");

    }

    @Override

    public void compileAndPackage() {

        System.out.println("自动进行编译&打包......");

    }

    @Override

    public void copyToTestServer() {

        System.out.println("自动将包拷贝到测试环境服务器......");

    }

    @Override

    public void testing() {

        System.out.println("执行自动化测试......");

    }

}

```

单元测试

```java
public class Client {

    public static void main(String[] args) {

        System.out.println("开始本地手动发布流程======");

        DeployFlow localDeployFlow = new LocalDeployFlow();

        localDeployFlow.buildFlow();

        System.out.println("********************");

        System.out.println("开始 CICD 发布流程======");



        DeployFlow cicdDeployFlow = new CicdDeployFlow();

        cicdDeployFlow.buildFlow();

    }

}

//输出结果

开始本地 手动发布流程======

手动将代码拉取到本地电脑......

在本地电脑上手动执行 编译打包......

手动通过 SSH 上传包 到 本地的测试服务......

执行手工测试......

统一自动上传 启动App包到对应线上服务器

统一自动 启动线上App

********************

开始 CICD 发布流程======

持续集成服务器将代码拉取到节点服务器上......

自动进行编译&打包......

自动将包拷贝到测试环境服务器......

执行 自动化 测试......

统一自动上传 启动App包到对应线上服务器

统一自动 启动线上App

```



### 优劣

#### 优点

1. 有效去除重复代码
2. 有助于找到更通用的模板

#### 缺点

1. 不符合开闭原则
2. 增加代码阅读的难度
3. 违反里氏替换原则





## 策略模式： 如何解决不同活动策略的营销推荐场景

> 常见的应用场景是 ： **利用它来替换过多的if-else嵌套的逻辑判断**



### 模式原理分析

> 原始定义  : 定义一系列算法，封装每个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化
>
> 策略模式明确表示应当**由客户端自己决定在什么样的情况下使用那些具体的策略**

![image-20210712145415334](img/image-20210712145415334.png)

```java 
public class Context {

    public void request(Strategy s) {

        s.operation();

    }

}

public interface Strategy {

    void operation();

}

public class StrategyA implements Strategy {

    @Override

    public void operation() {

        System.out.println("=== 执行策略 A ......");

    }

}

public class StrategyB implements Strategy {

    @Override

    public void operation() {

        System.out.println("=== 执行策略 B ......");

    }

}

```

> 策略模式的本质就是通过上下文信息类来作为中心控制单元，对不同的策略进行调度匹配



### 使用场景分析

1. 系统中需要动态切换几种算法的场景
2. 使用多重的条件选择语句来实现的业务场景
3. 只希望客户端选择已经封装好的算法场景而不用关心算法实现细节
4. 分离使用策略和创建策略的场景

> example : 在日常的网上购物中，我们都希望购买到价格实惠的商品，而网站通常也会定期搞一些促销活动，比如，满 XXX 元减 XX 元、N 折扣、M  元秒杀等。这些活动通常是运营部门来制定的，运营希望能通过商品编号来推荐不同的促销活动。这时，作为系统的开发者，我们就需要开发针对一系列的营销策略进行推荐的系统功能。

```java 
public interface PromotionStrategy {

    /**

     * 返回1 代表 可以参加 满减活动

     * 返回2 代表 可以参加 N折优惠活动

     * 返回3 代表 可以参加 M元秒杀活动

     */

    int recommand(String skuId);

}
// 三种不同策略进行方法实现
public class FullReduceStrategy implements PromotionStrategy {



    @Override

    public int recommand(String skuId) {

        System.out.println("=== 执行 满减活动");

        //推荐算法和逻辑写这里

        return 1;

    }

}

public class NPriceDiscountStrategy implements PromotionStrategy {

    @Override

    public int recommand(String skuId) {

        System.out.println("=== 执行 N 折扣优惠活动");

        //推荐算法和逻辑写这里

        return 2;

    }

}

public class MSpikeStrategy implements PromotionStrategy {

    @Override

    public int recommand(String skuId) {

        System.out.println("=== 执行 M 元秒杀活动");

        //推荐算法和逻辑写这里

        return 3;

    }

}
// 通过参数判断使用那种促销策略
public class Promotional {

    private final PromotionStrategy strategy;

    public Promotional(PromotionStrategy strategy) {

        this.strategy = strategy;

    }

    public void recommand(String skuId) {

        strategy.recommand(skuId);

    }

}
// 测试
public class Client {

    public static void main(String[] args) {

        Promotional fullReducePromotional = new Promotional(new FullReduceStrategy());

        fullReducePromotional.recommand("1122334455");

        Promotional nPriceDiscountPromotional = new Promotional(new NPriceDiscountStrategy());

        nPriceDiscountPromotional.recommand("6677889900");

        Promotional mSpikePromotional = new Promotional(new MSpikeStrategy());

        mSpikePromotional.recommand("11335577");

    }

}

//输出结果

=== 执行 满减活动

=== 执行 n折扣优惠活动

=== 执行 m元秒杀活动

```



### 为什么使用策略模式

1. 为了提升代码的可维护性
2. 为了动态快速地替换更多的算法
3. 为了应对频繁更换策略的场景



### 优劣比

#### 优势

1. 提供良好的代码扩展性
2. 提供了一种管理多个不同算法策略的办法
3. 提供使用组合替换继承的办法
4. 能够降低使用多重条件if-else 嵌套语句的理解难度
5. 在运行时动态切换算法，提升代码灵活性

#### 劣势

1. 客户端学习成本变高
2. 具体策略里的数量会剧增，增加维护成本
3. 不如函数式编程简洁





## 状态模式： 如何通过有限状态机监控功能的“状态变化”



### 模式原理分析

> 定义： 容许一个对象在其内部状态改变时改变他的行为，对象看起来似乎修改了自己的类一样。
>
> 换句话说： **状态模式就是让一个对象通过定义一系列状态的变化来控制行为的变化**。 比如 ，给购买的物品定义几个包裹运送状态，已下单、运送中、已签收等。

![image-20210713090530080](img/image-20210713090530080.png)

```java
public interface State {

    void handle(Context context);

}

public class StateA implements State{

    private static StateA instance = new StateA();

    public StateA() {

    }

    public static StateA instance(){

        return instance;

    }

    @Override

    public void handle(Context context) {

        System.out.println("=== 进入状态A");

        context.setCurrentState(StateB.instance());

    }

}

public class StateB implements State {

    private static StateB instance = new StateB();

    public StateB() {

    }

    public static StateB instance(){

        return instance;

    }

    @Override

    public void handle(Context context) {

        System.out.println("=== 进入状态B");

        context.setCurrentState(this);

    }

}

public class Context {

    private State currentState;

    public Context(State currentState) {

        this.currentState = currentState;

        if (null == currentState) {

            this.currentState  = StateA.instance();

        }

    }

    public State getCurrentState() {

        return currentState;

    }

    public void setCurrentState(State currentState) {

        this.currentState = currentState;

    }

    public void request(){

        currentState.handle(this);

    }

}

```



> 核心在于**找到合适的抽象状态以及状态之间的转移关系，通过改变状态来达到改变行为的目的。



### 使用场景分析

1. 对象根据自身状态的变化来进行不同行为的操作时，
2. 对象需要根据自身变量的当前值改变行为，不期望使用大量if-else 语句
3. 对于某些确定的状态和行为，不想使用重复代码时

#### 案例 ： 线上购物的过程

![image-20210713094743975](img/image-20210713094743975.png)

```java
public interface PackageState {

    

    /**

     * 定义了6种状态

     * 1 - 已下单

     * 2 - 仓库处理中

     * 3 - 运输中

     * 4 - 派送中

     * 5 - 待取件

     * 6 - 已签收

     * @param ctx

     */

    void updateState(PackageContext ctx);

}
public class PackageContext {

    private PackageState currentState;

    private String packageId;

    public PackageContext(PackageState currentState, String packageId) {

        this.currentState = currentState;

        this.packageId = packageId;

        if(currentState == null) {

            this.currentState = Acknowledged.instance();

        }

    }

    public PackageState getCurrentState() {

        return currentState;

    }

    public void setCurrentState(PackageState currentState) {

        this.currentState = currentState;

    }

    public String getPackageId() {

        return packageId;

    }

    public void setPackageId(String packageId) {

        this.packageId = packageId;

    }

    public void update() {

        currentState.updateState(this);

    }

}
1 - 已下单

public class Acknowledged implements PackageState {

    //Singleton

    private static Acknowledged instance = new Acknowledged();

    private Acknowledged() {}

    public static Acknowledged instance() {

        return instance;

    }



    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("=== state start...");

        System.out.println("1 - Package is acknowledged !!");

        ctx.setCurrentState(WarehouseProcessing.instance());

    }

}

public class WarehouseProcessing implements PackageState  {

    //Singleton

    private static WarehouseProcessing instance = new WarehouseProcessing();

    private WarehouseProcessing() {}

    public static WarehouseProcessing instance() {

        return instance;

    }



    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("2 - Package is WarehouseProcessing");

        ctx.setCurrentState(InTransition.instance());

    }

}

public class InTransition implements PackageState {

    //Singleton

    private static InTransition instance = new InTransition();

 

    private InTransition() {}

 

    public static InTransition instance() {

        return instance;

    }

     

    //Business logic and state transition

    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("3 - Package is in transition !!");

        ctx.setCurrentState(Delivering.instance());

    }

}

public class Delivering implements PackageState {

    //Singleton

    private static Delivering instance = new Delivering();

    private Delivering() {

    }

    public static Delivering instance() {

        return instance;

    }

    //Business logic

    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("4 - Package is Delivering !!");

        ctx.setCurrentState(WaitForPickUp.instance());

    }

}

public class WaitForPickUp implements PackageState {

    //Singleton

    private static WaitForPickUp instance = new WaitForPickUp();

    private WaitForPickUp() {}

    public static WaitForPickUp instance() {

        return instance;

    }

    //Business logic and state transition

    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("5 - Package is waiting for pick up !!");

        ctx.setCurrentState(Received.instance());

    }

}

public class Received implements PackageState {

    //Singleton

    private static Received instance = new Received();

    private Received() {}

    public static Received instance() {

        return instance;

    }

    //Business logic and state transition

    @Override

    public void updateState(PackageContext ctx) {

        System.out.println("6 - Package is Received !!");

        System.out.println("=== state end ");

    }

}

```

```java
public class Client {

    public static void main(String[] args) {

        PackageContext ctx = new PackageContext(null, "Test123");

        ctx.update();

        ctx.update();

        ctx.update();

        ctx.update();

        ctx.update();

        ctx.update();

    }

}

//输出结果

=== state start...

1 - Package is acknowledged !!

2 - Package is WarehouseProcessing

3 - Package is in transition !!

4 - Package is Delivering !!

5 - Package is waiting for pick up !!

6 - Package is Received !!

=== state end

```



### 为什么使用状态模式

1. 当要设计的业务具有复杂的状态变迁时，我们期望通过状态变化来快速进行变更操作，并降低代码耦合性
2. 避免增加代码的复杂性



### 优劣势

#### 优势

1. 提前定好可能的状态，降低代码实现复杂度
2. 快速理解状态和行为之间的关系
3. 避免写大量的if-else 条件语句
4. 可以让多个环境对象共享一个状态对象，从而减少重复代码

#### 劣势

1. 造成很多零散类
2. 状态切换关系越复杂，代码实现难度越高
3. 不满足开闭原则



## 观察者模式： 如何发送消息变化的通知

> 观察者模式  也可以 称作 是 **订阅-发布模式**。  在商品系统，物流系统，监控系统，运营数据分析系统等使用广泛
>
> 基于事件驱动的架构，就是观察者模式一种最佳实践



### 模式原理分析

> 定义： 定义对象之间的一对多依赖关系，这样当一个对象改变状态时，他的所有依赖项都会自动得到通知和更新

![image-20210713102935227](img/image-20210713102935227.png)

```java
public interface Publisher {

    void addObserver(Observer o);

    void removeObserver(Observer o);

    void notify(double amt);

}

public class PublisherImpl implements Publisher {

    private String acct;

    private double balance;

    private List<Observer> myObservers;

    public PublisherImpl(String anAcct, double aBalance) {

        acct = anAcct;

        balance = aBalance;

        myObservers = new ArrayList();

    }

    public void addObserver(Observer o){

        myObservers.add(o);

    }

    public void removeObserver(Observer o) {

        myObservers.remove(o);

    }

    public void notify(double amt) {

        balance -= amt;

        if(balance < 0) {

            overdrawn();

        }

    }

    private void overdrawn() {

        for (Observer o: myObservers) {

            o.notify(acct, balance);

        }

    }

}

public interface Observer {

    void notify(String acct, double amt);

}

public class ObserverImpl implements Observer {

    @Override

    public void notify(String acct, double amt) {

        System.out.println("=== 接收到通知：账户："+acct + " 账单："+amt);

    }

}

public class Demo {

    public static void main(String[] args) {

        Publisher account = new PublisherImpl("TEST123", 10.00);

        Observer bill = new ObserverImpl();

        account.addObserver(bill);

        account.notify(11.00);

    }

}

//输出结果

=== 接收到通知：账户：TEST123 账单：-1.0

```

**实际上，发布者本身并不维护订阅列表，它会将工作委派给具体发布者；订阅者在接收到发布者的消息后，会委派具体的订阅者来进行相关的处理**



### 使用场景分析

1. 当一个对象状态的改变需要改变其他对象时
2. 一个对象发生改变时只想要发送通知，而不需要知道接收者是谁
3. 需要创建一种链式出发机制
4. 微博或朋友圈发送的场景
5. 需要建立基于事件出发的场景

#### 案例

简易的消息订阅通知功能

```java 
public interface MessageObserver {

    void update(Message m);

}
public interface Subject {

    void attach(MessageObserver o);  //增加观察者

    void detach(MessageObserver o);  //删除观察者

    void notifyUpdate(Message m);    //更新通知

}
public class Message {

    final String content;

    public Message (String m) {

        this.content = m;

    }

    public String getContent() {

        return content;

    }

}
public class MessagePublisher implements Subject {

    private List<MessageObserver> observers = new ArrayList<>();

    @Override

    public void attach(MessageObserver o) {

        observers.add(o);

    }

    @Override

    public void detach(MessageObserver o) {

        observers.remove(o);

    }

    @Override

    public void notifyUpdate(Message m) {

        observers.forEach(x->x.update(m));

    }

}
public class MessageSubscriber1 implements MessageObserver {

    @Override

    public void update(Message m) {

        System.out.println("MessageSubscriber1 :: " + m.getContent());

    }

}

public class MessageSubscriber2 implements MessageObserver {

    @Override

    public void update(Message m) {

        System.out.println("MessageSubscriber2 :: " + m.getContent());

    }

}

public class MessageSubscriber3 implements MessageObserver {

    @Override

    public void update(Message m) {

        System.out.println("MessageSubscriber3 :: " + m.getContent());

    }

}
public class Client {

    public static void main(String[] args) {

        MessageObserver s1 = new MessageSubscriber1();

        MessageObserver s2 = new MessageSubscriber2();

        MessageObserver s3 = new MessageSubscriber3();

        Subject p = new MessagePublisher();

        p.attach(s1);//

        p.attach(s2);

        p.notifyUpdate(new Message("First Message"));   //s1和s2会收到消息通知

        p.detach(s1);

        p.attach(s3);

        p.notifyUpdate(new Message("Second Message")); //s2和s3会收到消息通知

    }

}

//输出结果

MessageSubscriber1 :: First Message

MessageSubscriber2 :: First Message

MessageSubscriber2 :: Second Message

MessageSubscriber3 :: Second Message

```

> 使用场景的特定在于---->  **找到合适的被观察者，定义一个通知列表，将需要通知的对象放到这个通知列表中，当被观察者需要发起通知时，就会通知这个列表中的所有人**



### 为什么使用观察者模式

1. 为了方便捕获观察对象的变化并及时做出相应的操作
2. 为了提升代码扩展性



### 优劣势

#### 优势

1. 能够降低系统与系统之间的耦合性
2. 提升代码扩展性
3. 可以建立一套基于目标对象特定操作或数据的出发机制

#### 劣势

1. 增加代码的理解难度
2. 降低了系统性能





**找到合适的变化并进行正确的处理才是使用观察者模式的正确打开方式**



## 备忘录模式： 如何在聊天会话中记录历史消息



### 模式原理分析

> 定义:  捕获并外部化对象的内部状态，以便以后可以恢复，所有这些都不会违反封装

![image-20210713104613673](img/image-20210713104613673.png)

```java
public class Originator {

    private String state = "原始对象";  //打印当前状态

    private String id;

    private String name;

    private String phone;

    public Originator() {

    }

    //省略get、set方法



    public Memento create() {

        return new Memento(id, name, phone);

    }

    public void restore(Memento m) {

        this.state = m.getState();

        this.id = m.getId();

        this.name = m.getName();

        this.phone = m.getPhone();

    }

    @Override

    public String toString() {

        return "Originator{" +

                "state='" + state + '\'' +

                ", id='" + id + '\'' +

                ", name='" + name + '\'' +

                ", phone='" + phone + '\'' +

                '}';

    }

}

```

```java 
public class Originator {

    private String state = "原始对象";  //打印当前状态

    private String id;

    private String name;

    private String phone;

    public Originator() {

    }

    //省略get、set方法



    public Memento create() {

        return new Memento(id, name, phone);

    }

    public void restore(Memento m) {

        this.state = m.getState();

        this.id = m.getId();

        this.name = m.getName();

        this.phone = m.getPhone();

    }

    @Override

    public String toString() {

        return "Originator{" +

                "state='" + state + '\'' +

                ", id='" + id + '\'' +

                ", name='" + name + '\'' +

                ", phone='" + phone + '\'' +

                '}';

    }

}

```

```java 
public class Demo {

    public static void main(String[] args) {

        Originator originator = new Originator();

        originator.setId("1");

        originator.setName("mickjoust");

        originator.setPhone("1234567890");

        System.out.println(originator);

        Memento memento = originator.create();

        originator.setName("修改");

        System.out.println(originator);

        originator.restore(memento);

        System.out.println(originator);

    }

}

//输出结果

Originator{state='原始对象', id='1', name='mickjoust', phone='1234567890'}

Originator{state='原始对象', id='1', name='修改', phone='1234567890'}

Originator{state='从备份对象恢复为原始对象', id='1', name='mickjoust', phone='1234567890'}

```

**关键点就是在于要能保证原始对象在某一个时刻的对象状态被完整记录下来**

### 使用场景分析

1. 需要保存一个对象在某一个时刻的状态时
2. 不希望外界直接访问对象的内部状态时。

#### 案例： 博客系统

```java
public class Blog {

    private long id;

    private String title;

    private String content;

    public Blog(long id, String title) {

        super();

        this.id = id;

        this.title = title;

    }

    public long getId() {

        return id;

    }

    public void setId(long id) {

        this.id = id;

    }

    public String getTitle() {

        return title;

    }

    public void setTitle(String title) {

        this.title = title;

    }

    public String getContent() {

        return content;

    }

    public void setContent(String content) {

        this.content = content;

    }

    public BlogMemento createMemento() {

        BlogMemento m = new BlogMemento(id, title, content);

        return m;

    }

    public void restore(BlogMemento m) {

        this.id = m.getId();

        this.title = m.getTitle();

        this.content = m.getContent();

    }

    @Override

    public String toString() {

        return "Blog{" +

                "id=" + id +

                ", title='" + title + '\'' +

                ", content='" + content + '\'' +

                '}';

    }

}
public class BlogMemento {

    private final long id;

    private final String title;

    private final String content;

    public BlogMemento(long id, String title, String content) {

        super();

        this.id = id;

        this.title = title;

        this.content = content;

    }

    public long getId() {

        return id;

    }

    public String getTitle() {

        return title;

    }

    public String getContent() {

        return content;

    }

}
public class Client {

    public static void main(String[] args) {

        Blog blog = new Blog(1, "My Blog");

        blog.setContent("ABC");      //原始的文章内容

        System.out.println(blog);

        BlogMemento memento = blog.createMemento();   //创建blog的备忘录

        blog.setContent("123");      //改变内容

        System.out.println(blog);

        blog.restore(memento);       //撤销操作

        System.out.println(blog);    //这时会显示原始的内容

    }

}

```

**备忘录模式在频繁需要撤销与恢复的场景中能够发挥很好的作用**



### 为什么要使用备忘录模式

1. 为了记录多个时间点的备份数据
2. 需要快速撤销当前操作并恢复到某对象状态



### 优劣势

#### 优势

1. 能够快速撤销对对象状态的更改
2. 能够帮助缓存记录历史对象状态
3. 能够提升代码的扩展性

#### 劣势

1. 备忘录会破坏封装性
2. 备忘录的对象数据很大时，读取数据可能出现内存用尽的情况。



**因此，你在使用备忘录模式时，一定不要误认为它就是万能的备份模式，要合理评估对象所使用的内存空间，再确定是否使用备忘录模式**



## 中介者模式： 如何通过中间层来解决耦合过多的问题



### 模式原理分析

> 定义 :  中介者对象封装了一组对象之间的交互，这组对象会将他们的交互委托给中介者对象，而不是直接交互。

![image-20210713105719195](img/image-20210713105719195.png)

```java
public interface Mediator {

    void apply(String key);

}

public class MediatorImpl implements Mediator{

    @Override

    public void apply(String key) {

        System.out.println("最终中介者执行操作，key为："+key);

    }

}

public abstract class Component {

    private Mediator mediator;

    public Component(Mediator mediator) {

        this.mediator = mediator;

    }

    public abstract void exec(String key);

    public Mediator getMediator() {

        return mediator;

    }

}

public class ComponentA extends Component{

    public ComponentA(Mediator mediator) {

        super(mediator);

    }

    @Override

    public void exec(String key) {

        System.out.println("===在组件A中，通过中介者执行");

        getMediator().apply(key);

    }

}

public class ComponentB extends Component{

    public ComponentB(Mediator mediator) {

        super(mediator);

    }

    @Override

    public void exec(String key) {

        System.out.println("===在组件B中，通过中介者的操作");

        getMediator().apply(key);

    }

}

public class Demo {

    public static void main(String[] args) {

        Mediator mediator = new MediatorImpl();

        Component componentA = new ComponentA(mediator);

        componentA.exec("key-A");

        Component componentB = new ComponentB(mediator);

        componentB.exec("key-B");

    }

}

//输出结果

===在组件A中，通过中介者执行

最终中介者执行操作，key为：key-A

===在组件B中，通过中介者的操作

最终中介者执行操作，key为：key-B

```



### 使用场景分析

- 系统中对象之间存在复杂的引用关系时，比如，聊天系统；
- 通过一个中间对象来封装多个类中的共有行为时，比如，在分层架构中的 DAO 层和数据库 DB 层中间再引入一个读写分离和读写均衡的中间层；
- 不想生成太多的子类时。





### 为什么使用中介者模式

**第一个，解决对象之间直接耦合的问题，避免“一处修改多处”的连锁反应出现**。

**第二个，在结构上作为中转，解耦两个服务或系统之间的直接耦合关系**

**第三个，为了更便捷地统一协同对象之间的通信**



### 优劣势

#### 优势

1. **减少对象之间的直接交互，间接解耦过多依赖**
2. **减少子类的创建数量**
3. **简化各系统的设计和实现**

#### 劣势

1. **中介者类中的交互逻辑可能变得非常复杂且难以维护**
2. **中介者变成了新的重度依赖对象**。
3. **中介者需要知道所有对象交互的逻辑**