第八章_java集合
    java集合是一种特别用的工具，，可以保存栈，队列等。
    java集合可分为Set，List，Queue，Map{
        Set  ； 代表无序、不可重复的集合
        List ： 代表有序，重复的集合
        Map  ： 代表具有映射关系的集合
        Queue： 代表一种队列集合的实现
    }

    在这里，主要了解四种集合的常规功能，深入介绍各集合实现类的所提供的独特功能，和他们的实现机制，
    还要区别出他们的用法上的细微差别，并给出不同应用场景选择不同的集合的建议

    8.1 java集合的概述
        集合与数组是不一样的，数组可以保存基本类型的值，或者对象，但是集合只能保存的是对象，
            上面所说的对象，，其实都是对象的引用变量。
        java的集合类是有两个接口派生出来的：Collection 和Map 是根接口，

        对于这章，，不会写关于并发控制安全的类
        重点在多线程的哪章会讲解


        最常用的类：{HashSet , TreeSet,ArrayDeque, LinkedList,HashMap,TreeMap}等实现类

    8.2 Collection 和 Iterator 接口
        list和set和queue 接口的父接口，，该接口里定义的方法即用于操作set集合，也可以用于操作list和queue集合，

        具体的方法，像是，添加对象，删除对象，清空容器，判断容器，是否为相等的方法都可以在api找到，，只需要明白，容器可以
            用来做什么，不能做什么就行了。
        8.2.1 使用Lambda 表达式遍历集合
            java8为iterable 接口新增了一个forEach（Consumer action）默认方法，该方法所需的参数是一个函数式接口，
            这个可以用lambda 来遍历集合元素
        8.2.2 使用java8 曾明强的iterator 遍历集合元素
            iterator 主要用来就是遍历集合的元素，，其他没有任何的功能，，当他有一个对象的时候，他必须要依附在一个Collection
                对象上，才可以保持存在。
            所以简单来说，，他连修改集合的元素，都不能够进行，如果你想要remover强行进行，会有报错的。
        8.2.3 使用lambda 表达式遍历Iterator
            java8 新增一个forEachRemaining 的方法，这个跟forEach的方法，在我看来没有，没有太大的差别，
        8.2.4 使用foreach 循环遍历集合元素
            foreach的代码与Iterator是一样的，他们有着共同的特性，都是不能修改集合的值，，不然会出现
                Concurrent ModificationException 的异常
        8.2.5 使用java8新增的Predicat 操作集合
            这个方法的参数的是一个Predicate 的对象，这个也是一个函数式接口，所有可以也是可以使用lambda表达式作为参数的

            新增了一个removeif（Predicate filter ）方法，，这个方法可以批量删除符合filter条件的所有元素，
            而且这种简便方法，可以在集合的需求中，可以用很少的代码就可以得到需求

        8.2.6 使用java8 新增的Stream 操作集合
            java8 新增了Stream，IntStream，LongStream，DoubleStream 等流式API，，这些代表多个支持串行和并行聚集操作的元素。

            独立使用这个步骤{
                1.使用Stream 或 XxxStream的builder 来方法创建该Stream 对应的Buider
                2.重复调用Buider 的add（）的方法向该流中添加多个元素
                3.调用Buider 的build 方法获取对应的Stream
                4.调用Stream的聚集方法。
            }
            对于大部分聚集方法而言，每个Stream只能执行一次

            Stream提供了大量的方法可以进行聚集操作，，这中方法可以是中间的，也可以是末端的
                中间的方法： 中间操作容许流保持打开状态
                末端的方法； 是对流的最终搓澡，
                常用的方法可以看api，，进行学习，

                而且这里，还可以有流Stream进行对集合的操作
    8.3 Set集合
        set集合是跟Connection非常相似的，没有提供任何额外的方法，实际上set就是Collection，只是行为不同（就是不能有重复值）


        8.3.1 HashSet类
            这是Set集合的典型实现，这个类就是用Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。
            还具有以下的特定：{
                元素无顺序
                无法自动同步，人工进行多线程同时访问一个HashSet
                里面的元素值可以容许空
            }

            这个类里面判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashcode方法的返回值也相等。
            可以通过代码，看到HashSet判断集合元素相同的标准

            这里有个重要点： 规则是：如果两个对象通过equals()方法比较返回true ，这两个对象的hashcode的值，，也应该是相同的
                        HashSet 中时，，equals和hashCode的两个方法都应该一起重写。
            但是如果两个没有一致判断，，导致的错误很严重


            而哈希的算法的价值就是速度，，上面的两个错误就是导致 速度的下降，和异常
            下面是重写 hashCode的一般步骤：{
                1. 把对象内每个有意义的实例变量（即每个参与equals() 方法比较标准的实例变量） 计算出一个int类型的hashCode值，计算方式
                2. 用第一步计算出来的多个hashCode值组合计算出来一个hashCode值返回，
            }
        8.3.2 LInkedHashSet类
            这个类也是根据元素的Hash值算出来的存储位置，只是他同时也是用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。

            这个类，是以链表来维护内部顺序的

        8.3.3 TreeSet 类
            这个类是SortedSet 接口的实现类，他可以确保集合元素的处于排序状态，
            他的方法就是获取前面一个元素和后面一个元素，很简单，可以看api

            他的存储结构是：红黑树的数据结构，
            他的排序规则是  有两种方法：自然排序和定制排序

            1-- 自然排序
                tresSet 会调用元素的compareTO 方法来比较元素之间的大小，关系，然后进行升序排列，

                但是使用上面的方法就会导致treeSet类的元素都会一样的的，而且要实现对比，必须要每个元素都要实现Comparable 接口，。
                只有相同类的两个实例才会比较大小。

                总结：如果希望TreeSet能正常运行，就必要添加统一的元素

            2-- 定制排序
                实现定制排序，就是在创建TreeSet 集合对象时，提供一个Comparator 对象与该TreeSet
                集合关联，有这个来负责集合元素的排序逻辑，由于Computer 是一个函数式接口，因此可以使用lambda表达式

        8.3.4 EnumSet 类
            EnumSet 类是一个专为枚举类设计的集合类，所有元素都必须是指定枚举类型的枚举值，
            在这个内部，是以位向量的形式存储的，非常的紧凑和高效。
            这个集合不容许加入null元素，如果试图加入，会有空指针的异常
            类没有暴露任何构造器来创建该类的实。
            他有很多的类方法，，可以进行创建
        8.3.5 各 Set 实现类的性能分析
            Hashset比TreeSet 好（特别是最常用的添加，查询元素等操作。）
            但是set的三个实现类，都是线程不安全的，必须要保证元素修改的同步性，

    8.4 List集合
        List集合代表一个元素有序，可重复中每个元素都有其对应的顺序索引。并且容许有重复元素，通过索引来查找元素

        8.4.1 java8改进的List接口和LIstiterator 接口
            list增加了一些根据索引来操作集合元素的方法

            list 判断元素的方法就是equals 方法比较返回true

            还增加了sort和replaceall方法的，，但是sort方法必须要Comparator对象来控制元素排序

        8.4.2 ArrayList 和Vector 实现类
            这两个都是list的常用型，，
            这两个都是由数组实现的，封装了一个动态数组的，容许分配的Object数组。虽然他们都是数组，但是长度都是可以变化的
            但是Vector这个由于是很早就存在的集合，所在现在就是问题很大 ，不是必须就不要用这个，这里有一个是栈stack，，可以用ArrayDeque代替
        8.4.3 固定长度的List
            Arrays.ArrayList 是一个固定长度的List集合，程序只能访问该集合的元素，不可添加，删除等操作，

    8.5 Queue集合
        queue是模拟队列的集合，而队列所具有的特点都是具备的。通常，队列不容许随机访问队列中的元素

        而这个集合里面包含了一个Deque集合，代表一个双端队列，也可以当做栈的使用
        有两个实现类：ArrayDeque 和LinkedList

        8.5.1 PriorityQueue 实现类
            这个是一个标准的队列类，但是，他的进出是按照队列元素的大小进行排序，，
            不容许插入null元素，这个集合还是有两种排序方式：自然排序和定制排序。。方法和TreeSet方法一样

        8.5.2 Deque接口和ArrayDeque实现类
            实现类就是获取方法，我还是建议自己多练习，不会的看api

        8.5.4 各种线性表的性能分析
            ArrayList 是基于数组的线性表
            LinkedList 是介于链表的线性表
            Queue 代表了队列，Deque 代表了双端队列(既可以是栈也可以是队列)

            但是list 集合不是没有线程安全吗。可以使用Collections 将集合包装成线程安装的集合

    8.6 Map集合
        Map用于保存具有映射关系的数据， 数据是key-value 类型的保存
        所以这个也可以称为字典，或关联数组，

        8.6.1 新增的方法
            对于这些方法，，，我就不给自己写了，，，让自己去实战学习

        8.6.2  改进的HashMap 和Hashtable 实现类
            都是典型实现类，

            Hashtable 是一个线程安全的Map实现，
            Hashtable 不容许使用null作为key和value，，但是hashMap可以有一个key为null，，但是value无限制

    8.8 操作集合的工具类 Collections
        提供了很多的方法可以对元素进行排序和查询和修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制方法

        8.8.1 排序操作
            通过代码看

        8.8.2 查找、替换操作
        8.8.3 同步控制
            Collections的提供多个线程同步的方法
        8.8.4 设置不可变的集合
            三个方法可以变成不可变的结合
                emptyXxx，singletonXxx，unmodifiableXxx
                就可任意让集合对象变成只读形式

        8.8.5 java9新增的不可变集合
            of方法可以一行代码增加数量的元素
            但是是不可变的，因为程序不能向集合中添加元素，不能删除

            还有ofEntries 方法，，也可以创建多个entry对象

    8.9 繁琐的接口：Enumeration
        这个是很久的，，不看了





